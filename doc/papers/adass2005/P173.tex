\documentclass[11pt,twoside]{article}  % Leave intact
\usepackage{adassconf}
\begin{document}   % Leave intact


\paperID{P173}

\title{Implementing Arbitrary Measurement Equations With The MeqTree Module}
\titlemark{mplementing Arbitrary MEs With MeqTrees}

\author{O.M. Smirnov \& J.E. Noordam}
\affil{ASTRON, P.O. Box 2, 7990AA Dwingeloo, The Netherlands}

\contact{Oleg Smirnov}
\email{smirnov@astron.nl}

\paindex{Smirnov, O.M.}
\aindex{Noordam, J.E}     % Remove this line if there is only one author

\authormark{Smirnov \& Noordam}

%-----------------------------------------------------------------------
%			Subject Index keywords
%-----------------------------------------------------------------------
% Enter a comma separated list of up to 6 keywords describing your
% paper.  These will NOT be printed as part of your paper; however,
% they will be used to generate the subject index for the proceedings.
% There is no standard list; however, you can consult the indices
% for past proceedings (http://adass.org/adass/proceedings/).
%
% EXAMPLE:  \keywords{visualization, astronomy: radio, parallel
%                     computing, AIPS++, Galactic Center}
%
% In this example, the author noticed that "radio astronomy" appeared
% in the ADASS VII Index as "astronomy" being the major keyword and
% "radio" as the minor keyword.  The colon is used to introduce another
% level into the index.

\keywords{  }

\begin{abstract}           

A Measurement Equation is a mathematical model of an instrument (e.g. a radio
telescope) and the observed object(s). It can be used to predict  the data
measured with the instrument. In general, calibration of an observation (e.g.
selfcal in radio astronomy) involves solving for parameters of an ME in some
shape or form. Most calibration packages implicitly or explicitly implement some
specific form of the ME. By sheer necessity, this involves making some
simplifying assumptions about the instrument and the observation. As new
instruments come on-line (WSRT LFFEs, LOFAR, etc.) we find ourselves pushing the
limits of these assumptions.

The MeqTree module provides a flexible system to implement Measurement Equations
of arbitrary structure and complexity, and to solve for arbitrary subsets of
their parameters. The presentation will demonstrate how the use of a more
complex ME gives better results than using the ones that are implicit in
existing radio astronomy reduction packages.

\end{abstract}

\section{Introduction}

A Measurement Equation (ME) predicts the data measured with a particular
instrument. It is a mathematical model of the instrument (e.g. a radio
telescope) and the observed object(s). 

MEs play a crucial role in the calibration of interferometric observations,
since these always require model fitting in some shape or form. The traditional
selfcal algorithm used in radioastronomy is a good example. In its simplest
formulation, it models the sky by a single point source, and the instrument by a
single gain/phase term per each antenna. Despite the apparent simplicity of this
model, it has served radioastronomers in good stead for over two decades!

In its closed form, the ME of an interferometer has been formulated by Hamaker
et al. (??). For practical calibration purposes, the ME has to be restated using
a limited number of parameters. Calibration with an ME then follows the
classical model-fitting loop: initialize parameters from apriori guesses -- use
the ME to predict observables -- compare to data -- adjust parameters -- repeat
to a (hopefully) satisfactory fit.

Thus, all existing calibration packages implicitly or explicitly implement an ME
in some simplified and {\em fixed} form. However, a fixed ME makes it very hard
if not impossible to calibrate for effects that are unaccounted for by the
software author. Even older instruments can push the envelope of existing
packages, but new instruments such as LOFAR and SKA make the situation worse by
magnitudes. These instruments require very sophisticated models with many ME
parameters which current packages are simply not equipped to handle. Moreover,
at the moment we can only guess which computationally tractable formulations of
the ME will actually work, and we can expect to continue experimenting with
different MEs as these instruments come on-line.

Clearly, what is needed is a {\em toolkit} for constructing and fitting MEs. 

\section{The MeqTree Concept}

The {\em MeqTree} (Measurement Equation Tree) module provides such a toolkit.
Any model or ME is, in the final analysis, nothing more than a mathematical
expression, and as such can be represented by a tree.

\subsection{Constructing MEs}

MeqTrees are constructed out of {\em MeqNodes}.\footnote{Technically speaking,
MeqTrees implement {\em directed acyclic graphs} since multiple parent nodes are
allowed. We retain the term ``trees'' for historical and aesthetic reasons.}
Nodes receive {\em MeqRequests} from their parents and pass them on to their
children, get {\em MeqResults} in return, perform some operation on them, and
return the result of that to their parents. A MeqRequest generally defines a
domain and gridding in {\em N-}D space (for example, time-frequency space), and
a MeqResult represents a sampling of some function over that domain, {\em with
optional perturbed values.}

A typical MeqNode represents some mathematical operation on the results of its
children. MeqTrees provide a large collection of node classes for most
mathematical operations, and new node classes may be added by writing a (usually
simple) C++ class. And important feature of MeqTrees is that tensor values and
tensor operations are represented in an elegant and economical way, which is a
natural way to deal with polarization (Hamaker et al. ??)

Thus, we can build a tree representing some any function or model or ME, and
evaluate that model simply by giving a request to the root node of the tree, and
waiting for a result to come back. And, of course, trees can be strung together
to arbitrary levels of complexity. Which is why MeqTrees allow us to implement
truly arbitrary MEs. Basically, {\em if you can write it down as an expression,
you can build it as a MeqTree.}

\subsection{Solving For MEs}

Building an ME is just half the job, what about fitting it to the observed data?
MeqTrees provide some specialized node classes to facilitate this. Figure 1
shows (in a very schematic form) a typical predict-fit-subtract tree:

\begin{itemize}

\item {\bf MeqParm} leaf nodes at the top of the tree represent ME parameters.
These can be atomic, or can in turn be functions of, e.g., frequency and time
(Mevius et al.\  2006, this volume). Any subset of MeqParms may be designated as
solvable; solvable MeqParms will return perturbed values along with their main
value.

\item {\bf CondEq} nodes (for conditioning equation) compare two tree branches
-- in this case the predict tree at the top, and the observed data supplied by a
{\em Spigot} node at the bottom -- and convert perturbed values into numeric
derivatives.

\item A {\bf Solver} node does the actual fitting. It takes the result of all
its CondEq children, collects the derivatives into a matrix, and executes one
step of the Levenberg-Marquant algorithm. This results in a set of {\em
parameter updates}, which are then sent back up to the solvable MeqParms. The
cycle is repeated until a satisfactory fit is reached, or for some maximum
number of iterations. The Solver node then returns a result.

\item A {\bf ReqSeq} node provides flow control. In Figure 1, it ensures that
first the Solver branch is executed, providing a model fit. Once the Solver
returns, the Subtract branch is executed, subtracting the fitted model from the
data. The residuals are then returned to a {\em Sink} node, which writes them
out to disk (e.g., to an AIPS++ Measurement Set).

\end{itemize}

Note that in real life we actually construct a {\em forest} of trees; Figure 1
merely represents a slice of the forest for one particular baseline. Typically,
all per-baseline trees will share a common solver, and common sky parameters at
the top of the tree. A full forest is practically impossible to visualize, so we
normally talk in terms of slices such as that in Figure 1.

MeqTrees allow one to solve for arbitrary parameters of an ME, with arbitrary
variation over the problem domain (e.g., representing parameters as polynomials
of frequency and time). Basically, {\em if you can write it down as an
expression, you can solve for it using MeqTrees.} (Of course, the data needs to
provide enough constraints to solve for the given parameters...)

\section{The MeqTree Module}

The MeqTree module is implemented by a software package loosely called {\em
MeqTimba}. MeqTimba contains the following components:

\begin{itemize}

\item A computational {\em kernel}, mostly implemented in C++ (also using
external libraries from AIPS++, FFTW, etc.) The kernel implements all MeqNode
classes,  basic facilities for creating MeqNodes and connecting them into trees,
and tools for controlling MeqTrees. 

\item A set of {\em I/O agents} to feed the kernel with data and to dispose of
the results. The current set includes agents for reading/writing AIPS++
Measurement Sets (MSs), and also agents for pipelining data over the network.

\item A control GUI called the {\em MeqBrowser} implemented in Python and PyQt.
The browser provides kernel control (bulding trees, attaching MSs, running
trees) and visualization. A very important feature of MeqTrees is {\em data
transparency}. Figure 2 proivides an example of the browser GUI.

\item A Python-based Tree Definition Language (TDL). TDL scripts can be loaded
and run by the browser, which feeds them to the kernel to construct and run
trees. TDL allows one to define MeqTrees in high-level terms. Even more
critically, the typical turnaround time for modifying an ME and trying it again
is measured in seconds. This makes the system remarkably easy to ``play with''. 

\end{itemize}

The important highlights of the design are:

\begin{itemize}

\item The kernel is (almost) entirely {\bf policy-free}; the concepts it operates with
are very basic (nodes and trees) and it has very little intrinsic knowledge of
the problem domain. All policy, and thus the problem domain (MEs, data format,
etc.), is defined from the scripting side with TDL. This makes the system
eminently adaptable to new instruments and new problem domains (including those
outside radioastronomy).

\item {\bf Data transparency}: each node maintains a {\em state record} that can be
examined from the browser. Thus, no model or ME is ever a black box -- the user
can choose to his tree to any level of depth or detail. Node states can also be
published into the browser as a tree runs, providing an execution history. This
gives the user unprecedented insight into what exactly is going on with the
system.

\item Anything can be {\bf visualized.} The browser provides built-in tools for
visualizing node results. Even more importantly, TDL scripts can define {\em
bookmarks} that provide ``canned'' views of the tree which the user can access
with a couple of mouse clicks. In fact, trees can contain ``visualization
branches'' that compute some sort of derived quantities that are not used in
calibration per se, but  provide valueable vizualizations (most of the plots in
Figure 2 are in fact from visualization branches.)

\item The kernel provides {\bf tree debugging and profiling} facilities that can
be controlled from the browser.

\item Trees are naturally parallelizable; MeqTimba has been designed with
parallelization in mind from the beginning. The current version of the
kernel is entirely single-threaded, but future development will allow for nodes
to execute in parallel and be distributed across a cluster. Note that the
intrinsic profiling facilities should also aid in determining optimal
parallelization strategies.

\end{itemize}

\section{Current Status And Future Directions}

The current version of MeqTimba is being tested on WSRT data. One current
project involves custom-built trees for high-dynamic-range calibration of a
complex field (3C343) which is hard to deal with using traditional selfcal due
to the presence of off-axis bright sources. Perfromance on par with existing
packages has been demonstrated (?? Brentjens ??), and current work aims to ``go
where no package has gone before'' and calibrate for much finer effects. A
second project aims to provide a set of canned {\em central point source} trees
for online and offline processing of full-polarization WSRT calibrator
observations.

In the near future, we will be applying MeqTrees to data from the new WSRT
Low-Frequency Front Ends (LFFEs), which should provide a preview of sorts of
what LOFAR will be up against. Another interesting test is the currently
operational WHAT station, which is a phased-array LOAR prototype that is linked
into the WSRT to provide an interesting example of a heterogenous interferometer
array.

MeqTrees will play an integral role in LOFAR calibration. The LOFAR {\em Local
Sky Model} (LSM; see Smirnov \& Noordam 2004, and Nijboer et al.\ this volume)
will use MeqTrees to represent sky sources; we see this as the only way to get a
handle on the complex low-frequency sky seen by LOFAR. The ionosphere also plays
a critical role in low-frequency observations and will require some sort of
more or less sophisticated model (Noordam MIM ??), here again MeqTrees are
expected to play a vital role.

\begin{references}

\reference Brentjens 343??
\reference Hamaker, MS
\reference Mevius MeqParm
\reference Nijboer LSM
\reference Smirnov \& Noordam LSM
\reference Noordam MIM

\end{references}

%-----------------------------------------------------------------------
%			      References
%-----------------------------------------------------------------------
% List your references below within the reference environment
% (i.e. between the \begin{references} and \end{references} tags).
% Each new reference should begin with a \reference command which sets
% up the proper indentation.  Observe the following order when listing
% bibliographical information for each reference:  author name(s),
% publication year, journal name, volume, and page number for
% articles.  Note that many journal names are available as macros; see
% the User Guide listing "macro-ized" journals.   
%
% EXAMPLE:  \reference Hagiwara, K., \& Zeppenfeld, D.\  1986, 
%                Nucl.Phys., 274, 1
%           \reference H\'enon, M.\  1961, Ann.d'Ap., 24, 369
%           \reference King, I.\ R.\  1966, \aj, 71, 276
%           \reference King, I.\ R.\  1975, in Dynamics of Stellar 
%                Systems, ed.\ A.\ Hayli (Dordrecht: Reidel), 99
%           \reference Tody, D.\  1998, \adassvii, 146
%           \reference Zacharias, N.\ \& Zacharias, M.\ 2003,
%                \adassxii, \paperref{P7.6}
% 
% Note the following tricks used in the example above:
%
%   o  \& is used to format an ampersand symbol (&).
%   o  \'e puts an accent agu over the letter e.  See the User Guide
%      and the sample files for details on formatting special
%      characters.  
%   o  "\ " after a period prevents LaTeX from interpreting the period 
%      as an end of a sentence.
%   o  \aj is a macro that expands to "Astron. J."  See the User Guide
%      for a full list of journal macros
%   o  \adassvii is a macro that expands to the full title, editor,
%      and publishing information for the ADASS VII conference
%      proceedings.  Such macros are defined for ADASS conferences I
%      through XI.
%   o  When referencing a paper in the current volume, use the
%      \adassxii and \paperref macros.  The argument to \paperref is
%      the paper ID code for the paper you are referencing.  See the 
%      note in the "Paper ID Code" section above for details on how to 
%      determine the paper ID code for the paper you reference.  
%

% Do not place any material after the references section

\end{document}  % Leave intact
