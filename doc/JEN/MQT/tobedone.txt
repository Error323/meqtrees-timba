file: ../doc/JEN/MQT/tobedone.txt
                                      last changed:   d25nov

NB: Just temporary: To be converted into Bugzilla items....!

 - JEN: TDL_Cohset.py: 
   - arrange for proper treatment of XX/YY only (etc)
   - selfcal for WHAT with WSRT XY/YX (14 only)

 - JEN: MG_JEN_Joneset.py:
   - dissimilar station (WHAT) 
 - JEN: TDL_Joneset.py:
   - dissimilar station (WHAT): no impact?
   - more transparent or default... (MXM)...?
   - Use scalar default values (0,1)
   - Allow later specification of shape (also via Joneset?)
   - Allow ND funklets......!

 - MXM/JEN/SBY: Tools for funklet creation.....
 - SBY/OMS: Domain dimensions.....

 - MXM: MeqParm default value discussion
   - separate default values from solve-shape      <----- !!
   - JEN proposal:
     - The scheme should be internally consistent: NO MORE KLUDGES!!
     - allow SCALAR default value only (default = 0.0)
       (only a scalar does not need a validity domain)
     - set the solve-shape when setting the MeqParm solvable
       - done by the Solver, using the rider
       - specify when creating the solver? how?
         - can only specify nr of coeff in each dimension,
           but NOT their values since that would require a validity domain,
           which we do not know. So the initial values should be zero?
           In that case, what about continuity?
       - change (dynamically?) afterwards?
       - NB: Can a MeqParm have funklets with different nrs of dimensions...?  
   - MXM: Treat polcs as different from funklets, i.e. funklets are NOT
          a generalisation of polcs....!?

 - MXM/JEN: MeqParm/solver modes
   - ALWAYS return values, arbitrary request
     - interpolations scheme
     - more efficient if successive/cotiguous domains?
     - mix of funklets with different dimensions?
     - also used for finding initial value for solving?
   - snippet-by-snippet solution
     - Always tiled solution (tile_size=1)?
     - MeqParm intelligence (growing domain)
       - Prediction of next value (convergence)
       - rejection of 'bad' solutions
       - more efficient table use (fewer polcs)
       - no extra cost if accumulating solution matrix
       - how to decide when to start new polc? overlap?
     - Smoothing of table polcs/funklets afterwards
       - simpler (more versatile?) scheme than above
       - has to be done in any case (edge discontinuities)
       - better rejection of 'bad' solutions (more info)
       - use last value as prediction for the next (almost as good)

 - MXM/JEN: BJones (Abell963)
   - solve for BJones on the central source, dt = 1 hr
     - takes care of slowly time-variable BJones
     - contamination from the other sources?
   - correct the uv-data for this BJones
   - solve for GJones on the central source, dt = 1 min
     - rapid gain variations, w.r.t. slow BJones
   - subtract the (corrupted) central source 
   - correct the uv-data for this GJones
   - then what?
     - position-dependent GJones 
       - extended source: requires uvbrick
     - position-dependent BJones? (very diffifult)

 - MXM/JEN: separate solvers
   - BJones/GJones: use Gpol1, GPol2 separately?
   - automatic?
   - reqseq structure?


 - Resampling:
   - improvement in speed?
   - degradation of the solution quality?
   - clashes with tiled solutions?
   - dynamic re-specification?

 - SBY: LSM files for WSRT calibrator fields
   - LSM node naming for (saved) LSM's
   - multiple versions of the same LSM in same tree (RJN)?

 - create_MS_interface_nodes()
   - split off the uv-coordinate nodes spec
   - need different set for different directions
     - but ONLY if the uv-data phase-centre has been shifted...?
     - MAB: For point sources, the uvw-coord for the pointing centre
       are correct. But for extended sources, things are different...
   - create a default set for the MS pointing centre (q=uvp?)

 - JEN: MG_JEN_peeling.py
   - correct the data for uv-plane effects (if available) first
     - GJones, BJones, DJones
   - solve for instrumental errors in the direction of peeling sources
     RELATIVE to uv-plane effects (also good diagnostic!)
   - Advantages:
     - uv-data are fit to make a reasonable map from
     - relative errors are sensitive diagnostic
     - convergence is quicker (start closer to solution)
     - just subtract (mildly corrupted) sources
     - no further uv-data correction needed   


 - SvdT: Webpage for script/object inspection
 - SvdT/OMS/MAB: Automatic module testing (3 levels)

 - JEN/SBY/GVD: WSRT/WHAT reduction
   - MG_JEN_Joneset: station-by-station specification
   - 4 WHAT tiles in fixed time-pattern
     - treat them as the same one 
       - position errors absorbed in phases
     - read in together (tile_size=4), and then...?
     - have 4 different trees, and switch between them (how?)
   - step either the WHAT or WSRT around the source (corr.coeff)
     - can we get/assume the RA,DEC pattern?
     - solving for WSRT/WHAT beams
     - visualising beamshapes
     - predicting projected dipole orthogonality


 - OMS/MXM: Sink 'tiling' in freq direction too...
 -      Has repercussions for MeqParm tables...
 - MXM/JEN: MeqParm functional/final description

 - MXM/WNB: Experiment with AIPS++ fitting improvements
 - AGW/JEN: Use LM parameter in 'debug' field of result

 - JEN: TDL_Antenna.py
   - Multiplication of voltage beams (rather than subtract)

 - JEN: TDL_common.py
   - Add a profiler of some kind (Why is Antenna tree definition so slow?)

 - JEN: TDL_result.py (object that dissects a result...)

 - JEN: TDL_display_subtree.py (from MG_JEN_exec.py)
 - JEN: TDL_display_nodescope.py (from MG_JEN_exec.py)
 - JEN: TDL_display_record.py (from MG_JEN_exec.py)

 - JEN: TDL_parameter_set.py (a record of function parameters)



                      ================================
