from Timba.TDL import *
from Timba import pynode
from Timba.Meq import meq
from Timba import mequtils
import struct
import math
import pyfits
from Meow import Context

_dbg = utils.verbosity(0,name='digestif');
_dprint = _dbg.dprint;
_dprintf = _dbg.dprintf;

class AxisFlipper (pynode.PyNode):
  """An AxisFlipper node remaps axes. Given an incoming request,
  it creates a new cells with out_axis_[12] copied from in_axis_[12], and
  passes that on to its child. It then modifies the child result
  my mapping out_axis back to in_axis.
  Note that the child request will only have the two out_axis in it. Also,
  no transposition of the result is done, so the in/out axis pairs
  must be in the same order w.r.t. each other in the axis map.
  """;
  def update_state (self,mystate):
    mystate('in_axis_1');
    mystate('in_axis_2');
    mystate('out_axis_1');
    mystate('out_axis_2');
    mequtils.add_axis(self.in_axis_1);
    mequtils.add_axis(self.in_axis_2);
    mequtils.add_axis(self.out_axis_1);
    mequtils.add_axis(self.out_axis_2);
    
  def modify_child_request (self,request):
    c0 = self.cells = request.cells;
    try:
      domain = meq.gen_domain(**{
        self.out_axis_1:c0.domain[self.in_axis_1],
        self.out_axis_2:c0.domain[self.in_axis_2]});
      self._shape = (len(c0.grid[self.in_axis_1]),len(c0.grid[self.in_axis_2]));
      cells = meq.gen_cells(domain,**{
        'num_'+self.out_axis_1:self._shape[0],
        'num_'+self.out_axis_2:self._shape[1]});
      return meq.request(cells=cells,rqid=request.request_id);
    except:
      print "Error forming up modified request:";
      traceback.print_exc();
      print "Using original request";
      return None;
  
  def get_result (self,request,*children):
    result = children[0];
    # restore original cells
    result.cells = self.cells;
    # change the shape of the vells to conform to original cells
    ax1 = mequtils.get_axis_number(self.in_axis_1);
    ax2 = mequtils.get_axis_number(self.in_axis_2);
    newshape = [1]*(max(ax1,ax2)+1);
    newshape[ax1] = self._shape[0];
    newshape[ax2] = self._shape[1];
    for vs in result.vellsets:
      vs.shape = newshape;
      vs.value.shape = newshape;
      if hasattr(vs,'perturbed_value'):
        for pval in vs.perturbed_value:
          pval.shape = newshape;
    return result;

class DigestifBeamReader (object):
  """This class reads a FITS file containing a Digestif beam.
  The FITS file is generated by the FITSWriter node.
  NAXIS1/2 is pointing l/m
  NAXIS3/4 is grid l/m
  The array dimensions appear to be in reverse order (FORTRAN? is that
  the FITS standard?): gm,gl,pm,pl
  """;
  def __init__ (self,filename):
    self.beamdata = pyfits.getdata(filename);
    # transpose beam data so that it is now in order of
    # pl,pm,gl,gm
    self.beamdata.transpose((3,2,1,0));
    hdr = pyfits.getheader(filename);
    print hdr.items();
    # sanity checks
    if hdr['BITPIX'] != -64:
      raise ValueError,"bad FITS file: BITPIX=-64 expected";
    if hdr['CPLEX'] != 1:
      raise ValueError,"bad FITS file: CPLEX=1 expected";
    if hdr['NAXIS'] != 4:
      raise ValueError,"bad FITS file: NAXIS=4 expected";
    # the first two axes represent pointing offsets in l/m
    self.npl = hdr['NAXIS1'];
    self.npm = hdr['NAXIS2'];
    # the second two axes represent the beam pattern in l/m
    self.ngl = hdr['NAXIS3']
    self.ngm = hdr['NAXIS4'];
    # now form up cells for the beam pattern
    l0,dl = hdr['CRVAL3'],hdr['CDELT2']; 
    m0,dm = hdr['CRVAL1'],hdr['CDELT1']; 
    self.domain = meq.gen_domain(l=[l0-dl/2,l0+(self.ngl-.5)*dl],
                                 m=[m0-dl/2,m0+(self.ngm-.5)*dm]);
    self.cells = meq.gen_cells(self.domain,num_l=self.ngl,num_m=self.ngm);
    # and create arrays for the l/m pointing offsets
    self.pl = hdr['CRVAL1']+numarray.arange(self.npl)*hdr['CDELT1'];
    self.pm = hdr['CRVAL2']+numarray.arange(self.npm)*hdr['CDELT2'];
    
  def get_beam_pattern (self,il,im,center=True):
    """Returns beam pattern for pointing #il,im. If center=True,
    il,im refer to the center pointing""";
    if center:
      il0 = (self.npl-1)/2;
      im0 = (self.npm-1)/2;
    else:
      il0 = im0 = 0;
    return self.beamdata[im0+il,il0+im,:,:];

class DigestifBeamNode (pynode.PyNode):
  def __init__ (self,*args):
    pynode.PyNode.__init__(self,*args);
    mequtils.add_axis('l');
    mequtils.add_axis('m');

  def update_state (self,mystate):
    mystate('file_name');
    mystate('nl',0);
    mystate('nm',0);
  
  def get_result (self,request,*children):
    beamreader = DigestifBeamReader(self.file_name);
    # get the beam pattern
    beam = beamreader.get_beam_pattern(self.nl,self.nm);
    cells = beamreader.cells;
    # reshape into an l/m vells
    print meq.shape(cells);
    print beam.shape;
    beam = meq.vells(meq.shape(cells),is_complex=True,value=beam);
    return meq.result(meq.vellset(beam),cells=beamreader.cells);

TDLCompileOption("beam_filename","Filename for beam pattern",
                  TDLFileSelect("*.fits",default="digestif-beam.fits"));
TDLCompileOption("beam_nl","Number of pointing in l",[0],more=int);
TDLCompileOption("beam_nm","Number of pointing in m",[0],more=int);

## this is to use this as a Jones module
def compute_jones (Jones,sources,stations=None,pointing_offsets=None,**kw):
  """Computes beam gain for a list of sources.
  The output node, will be qualified with either a source only, or a source/station pair
  """;
  stations = stations or Context.array.stations();
  ns = Jones.Subscope();
  # create node to read beam pattern
  ns.beam << Meq.PyNode(class_name="DigestifBeamNode",module_name=__file__,
                       file_name=beam_filename,nl=beam_nl,nm=beam_nm);
  # are pointing errors configured? then we have different beam Jones
  # per source, per station
  if pointing_offsets:
    # create nodes to compute actual pointing per source, per antenna
    for p in Context.array.stations():
      for src in sources:
        lm = ns.lm(src.direction,p) << src.direction.lm() + pointing_offsets(p);
        Jones(src,p) << Meq.Compounder(lm,ns.beam,dep_mask=255);
  # no pointing errors, single Jones per source
  else:
    for src in sources:
      Jones(src) << Meq.Compounder(src.direction.lm(),ns.beam,dep_mask=255);
      for p in Context.array.stations():
        Jones(src,p) << Meq.Identity(Jones(src));
  return Jones;


## this is for testing purposes
def _define_forest (ns,**kwargs):
  ns.beam << Meq.PyNode(class_name="DigestifBeamNode",module_name=__file__,
                       file_name=beam_filename,nl=beam_nl,nm=beam_nm,
                       cache_policy=100);

def _test_forest (mqs,parent,**kwargs):
  from Timba.Meq import meq
  # run tests on the forest
  cells = meq.cells(meq.domain(0,1,0,1),num_freq=20,num_time=10);
  request = meq.request(cells,rqtype='ev');
  mqs.execute('beam',request);

## for command-line testing
if __name__ == '__main__':
  beam = DigestifBeamReader('digestif-beam.fits');
  print "number of pointings:",beam.npl,beam.npm;
  print "pointing offsets:",beam.pl,beam.pm;
  print "beam cells:",beam.cells;
  print "beam for central pointing:",beam.get_beam_pattern(0,0).shape;
  print "beam array shape:",beam.beamdata.shape;
  