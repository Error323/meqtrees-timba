#LyX 1.4.3 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass book
\options a4
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1in
\topmargin 1cm
\rightmargin 1in
\bottommargin 1cm
\secnumdepth 3
\tocdepth 1
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle plain
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Title

\series bold
The TDL Bedside Companion
\series default
 
\newline

\family sans
\size normal
How To Find Your Way Among The Trees, And Much More Besides
\family default
\size default

\newline
\InsetSpace ~
\InsetSpace ~

\newline

\begin_inset External
	template RasterImage
	filename redhood.eps
	clip

\end_inset


\end_layout

\begin_layout Author
O.M.
 Smirnov
\newline

\family typewriter
smirnov@astron.nl
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \tableofcontents{}

\end_inset


\end_layout

\begin_layout Chapter*
Introduction
\end_layout

\begin_layout Standard
blah blah MeqTrees blah blah TDL blah blah
\end_layout

\begin_layout Section*
About the demo scripts
\end_layout

\begin_layout Standard
With a few exceptions, the demo scripts used here were originally developed
 for the second MeqTree Workshop (Dwingeloo, January--February 2007.) You
 can get a copy of all these scripts via our Subversion repository, under
 
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
Timba/doc/TDL_Companion/Scripts/
\end_layout

\begin_layout Standard
This directory should contain 
\emph on
all
\emph default
 the scripts used during the workshop, while the book covers only a subset.
 If you'd like to study the other scripts, then you should also refer to
 the workshop presentations under
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
Timba/doc/Courses/Workshop2007-Presentations/
\end_layout

\begin_layout Standard
for additional background material.
\end_layout

\begin_layout Chapter
Hello World
\end_layout

\begin_layout Standard
It has become a tradition to start any introduction to a programming language
 with a 
\begin_inset Quotes eld
\end_inset

Hello World
\begin_inset Quotes erd
\end_inset

 program.
 The first Hello World I ever saw was in Kernighan-Richie's classic 
\begin_inset Quotes eld
\end_inset

The C Programming Language
\begin_inset Quotes erd
\end_inset

.
 It is also one of the few Hello World programs that is truly transparent
 (look up a Java 
\begin_inset Quotes eld
\end_inset

Hello World
\begin_inset Quotes erd
\end_inset

 some time if you want an example of truly painful programming...) Unfortunately,
 a TDL 
\begin_inset Quotes eld
\end_inset

Hello World
\begin_inset Quotes erd
\end_inset

 will necessarily tend to be on the obtuse side, since TDL was designed
 for something other than printing frivolous messages.
\end_layout

\begin_layout Standard
Nevertheless, we can try to provide an equivalent (see 
\family typewriter
1-hello-world.py
\family default
):
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  from Timba.TDL import *
\end_layout

\begin_layout Standard

  
\end_layout

\begin_layout Standard

  def _define_forest (ns,**kwargs):
\end_layout

\begin_layout Standard

    ns.hello_world << Meq.Constant(value=0,message="Hello world!");
\end_layout

\begin_layout Standard

  
\end_layout

\begin_layout Standard

  print "Hello world!" 
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Despite looking a little bit odd (i.e.
 the 
\begin_inset Quotes eld
\end_inset


\family typewriter
<<
\family default

\begin_inset Quotes erd
\end_inset

 operator is in an unusual context), this script is undoubtedly pure Python.
 This is because TDL 
\emph on
is
\emph default
 Python.
 The point well-worth emphasizing:
\end_layout

\begin_layout Standard
\align center

\series bold
\size large
TDL is Python!!!
\end_layout

\begin_layout Standard
If you're not familiar with Python, now is the time to close this book and
 go read the excellent 
\emph on

\begin_inset Quotes eld
\end_inset

The Python Programming Language
\begin_inset Quotes erd
\end_inset


\emph default
 (???).
 Once you've done that, I recommend also getting 
\emph on

\begin_inset Quotes eld
\end_inset

The Python Cookbook
\begin_inset Quotes erd
\end_inset


\emph default
 and keeping it somewhere where you're likely to broswe it often, a few
 pages at a time.
 Python has many elegant mechanisms for getting complex jobs done quickly,
 and TDL is designed to take full advantage of them; the 
\emph on
Cookbook
\emph default
 is a great resource for neat and useful little Python tricks.
\end_layout

\begin_layout Standard
Now then, what happens if you run this script? Of course, you can just run
 it through Python from the command line:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

$ python 1-helloworld.py 
\end_layout

\begin_layout Standard

Debug: registered context Global=0 
\end_layout

\begin_layout Standard

Registered verbose context: tdl = 0 
\end_layout

\begin_layout Standard

Registered verbose context: pixmaps = 0 
\end_layout

\begin_layout Standard

Registered verbose context: meqds = 0 
\end_layout

\begin_layout Standard

Registered verbose context: widgets = 0 
\end_layout

\begin_layout Standard

Registered verbose context: gw = 0 
\end_layout

\begin_layout Standard

Registered verbose context: octopussy = 0 
\end_layout

\begin_layout Standard

Registered verbose context: tdlopt = 0 
\end_layout

\begin_layout Standard

Hello world!
\end_layout

\begin_layout Standard

$
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given that TDL is Python, the result is rather predictable: the 
\family typewriter
import
\family default
 statement pulls in some modules (which result in the debug messages at
 the top), then there's a function being defined (seemingly to no purpose),
 and then the 
\family typewriter
print
\family default
 statement at the top level produces 
\begin_inset Quotes eld
\end_inset

Hello world!
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
To see the real point of this script, we have to run it via MeqTrees.
\end_layout

\begin_layout Section
Browsers, kernels, trees: a quick primer
\end_layout

\begin_layout Standard
MeqTrees consists of three main components:
\end_layout

\begin_layout Itemize
A GUI called the 
\emph on
MeqBrowser
\emph default
 (or simply the 
\emph on
browser
\emph default
 for short.) This is the only piece of software that you will be interacting
 with directly.
 The browser is responsible for running TDL scripts, defining trees, controlling
 trees, and visualizing the results.
\end_layout

\begin_layout Itemize
The trees defined inside the browser are passed on to a 
\emph on
kernel
\emph default
 (a.k.a.
 the meqserver) for execution.
 The kernel runs as a separate process --- potentially, even on a different
 machine.
 The kernel is where all the computational heavy lifting occurs.
 It is meant to be lean, mean and fast, with all the complex eye candy such
 as visualization passed off to the browser.
\end_layout

\begin_layout Itemize
A set of importable TDL modules and frameworks, including those contributed
 by other users, which your scripts can make use of.
\end_layout

\begin_layout Standard
To start the browser, you run the following command:
\end_layout

\begin_layout Standard

\family typewriter
$ meqbrowser.py
\end_layout

\begin_layout Standard
...and if all goes well, a GUI window will appear.
 
\end_layout

\begin_layout Standard
The first thing the browser needs to do is to start a kernel process, which
 it offers to do through the dialog in Figure\InsetSpace ~

\begin_inset LatexCommand \ref{1-connectdialog}

\end_inset

.
 Just click OK to start a local process.
\begin_inset Foot
status open

\begin_layout Standard
The option to run a remote kernel was not fully functional at time of writing,
 so it was greyed out.
 If you see it available in your GUI, then your version of MeqTrees is a
 lot newer than this manual!
\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Caption
\begin_inset LatexCommand \label{1-connectdialog}

\end_inset

The 
\begin_inset Quotes eld
\end_inset

Connect
\begin_inset Quotes erd
\end_inset

 dialog
\end_layout

\begin_layout Standard
\align center
\begin_inset External
	template RasterImage
	filename 1-connectdialog.eps
	rotateAngle 270
	scale 30

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now we can load our Hello World script.
 Select the 
\family sans
TDL | Load & compile TDL script
\family default
 menu option (or press 
\family sans
Ctrl+T
\family default
).
 If all goes well, you'll see a message to the effect that 
\begin_inset Quotes eld
\end_inset

script has run successfully
\begin_inset Quotes erd
\end_inset

, and you'll see 
\family sans
+Root nodes (1)
\family default
 show up in the 
\begin_inset Quotes eld
\end_inset

Trees
\begin_inset Quotes erd
\end_inset

 panel on the left side of the screen.
 Click on the icon next to the 
\family sans
Root nodes
\family default
 label to open it up, then click on the 
\family sans
hello_world
\family default
 entry, to see something like Figure\InsetSpace ~

\begin_inset LatexCommand \ref{1-helloworld}

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Caption
\begin_inset LatexCommand \label{1-helloworld}

\end_inset

The browser, looking at the hello world node
\end_layout

\begin_layout Standard
\align center
\begin_inset External
	template RasterImage
	filename 1-helloworld.png.eps
	rotateAngle 270
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Defining a node
\end_layout

\begin_layout Standard
Now, what do we see here? We can see that we've created one 
\emph on
node
\emph default
 called 
\family sans
hello_world
\family default
, of class 
\family sans
MeqConstant
\family default
.
 We can see its 
\emph on
state record
\emph default
 in the panel on the right.
 The latter is full of stuff we don't need to worry about at the moment,
 but if you look carefully, you'll see a field called 
\family sans
value
\family default
, and a field called 
\family sans
message
\family default
, with values of 0 and 
\begin_inset Quotes eld
\end_inset

Hello world!
\begin_inset Quotes erd
\end_inset

, respectively.
 
\end_layout

\begin_layout Standard
This situation was brought about by this bit of code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def _define_forest (ns,**kwargs):
\end_layout

\begin_layout Standard

  ns.hello_world << Meq.Constant(value=0,message="Hello world!"); 
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, 
\family typewriter
_define_forest()
\family default
 here is a predefined TDL name.
 When you run a TDL script inside the browser, it looks for a function by
 that name, and invokes it (try loading a script without a 
\family typewriter
_define_forest()
\family default
, and observe the results.) In that sense it is exactly like the 
\family typewriter
main()
\family default
 function of a C/C++ program --- it is supposed to be the entrypoint to
 your script that does all of the work.
\end_layout

\begin_layout Standard
When the browser calls 
\family typewriter
_define_forest()
\family default
, it gives it a parameter called the 
\emph on
node scope
\emph default
 (
\family typewriter
ns
\family default
).
 The node scope is a magical little object that is pretty much at the heart
 of TDL.
 The 
\family typewriter
**kwargs
\family default

\begin_inset Foot
status collapsed

\begin_layout Standard
If you're not familiar with the Python 
\begin_inset Quotes eld
\end_inset

**
\begin_inset Quotes erd
\end_inset

 syntax, now is the time to close this book again, and go back to 
\emph on

\begin_inset Quotes eld
\end_inset

The Python Programming Language
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

 entry serves to catch any optional named parameters which may be supplied
 by future versions of the browser, and which we needn't concern ourselves
 with here.
\end_layout

\begin_layout Standard
The main purpose of the node scope is to allow us to 
\emph on
name
\emph default
 nodes.
 We'll be examining scopes in more detail later on; for now, all that matters
 is that if 
\family typewriter
ns
\family default
 is a node scope object, then 
\family typewriter
ns.
\emph on
name
\family default
\emph default
 declares a node called 
\emph on

\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset


\emph default
.
 Since in Python terms everything is an object, 
\family typewriter
ns.
\emph on
name
\family default
\emph default
 is an object too.
 We call such an object a 
\emph on
node stub
\emph default
.
\end_layout

\begin_layout Standard
Taken by itself, a node stub is not yet a real node, because we haven't
 described what kind of a node it is.
 We do this by 
\emph on
defining
\emph default
 a node.
 To define a node (i.e.
 to turn a node stub into a fully-fledged node on the kernel side), we create
 a 
\emph on
node definition
\emph default
 --- in this case, by calling 
\family typewriter
Meq.Constant()
\family default
 --- and 
\emph on
bind
\emph default
 that definition to a node stub using the Python 
\family typewriter
<<
\family default
 operator.
\begin_inset Foot
status open

\begin_layout Standard
The normal meaning of 
\family typewriter
<<
\family default
 is bitwise shift, which is only applicable to Python integers.
 TDL redefines this operator for node stub objects, so as to perform binding
 between a node stub and a node definition.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There's some potential for confusion here, so this deserves to be reiterated.
 Nodes as such only exist on the kernel side of things.
 On the TDL side, they're represented by node stubs.
 To define a node on the kernel side, we have to make a node stub on the
 TDL side, and bind it with a definition.
 The node stub is the TDL equivalent of a kernel-side node, so sometimes
 the two terms are used interchangably.
 There is an important difference though -- not all node stubs get turned
 into nodes.
 If you don't bind a node stub with a definition, it will remain a 
\begin_inset Quotes eld
\end_inset

potential
\begin_inset Quotes erd
\end_inset

 node in TDL, and no kernel-side counterpart will be created.
 When you do bind a node stub, the result is called an 
\emph on
initialized
\emph default
 node stub -- and a 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 node counterpart will be created by the kernel.
\end_layout

\begin_layout Standard
To make a node definition, we need, as a minimum, to specify a node class
 --- in this case, calling 
\family typewriter
Meq.Constant()
\family default
 specifies a node class of 
\family typewriter
MeqConstant
\family default
.
 As you'll see in the examples later on, in most simple cases the node class
 by itself is sufficient.
 Sometimes, though, you want to pass some optional arguments to a node.
 A 
\family typewriter
MeqConstant
\family default
 node needs a value --- this is passed in via the 
\family typewriter
value
\family default
 argument.
 You'll notice we also pass it a 
\family typewriter
message
\family default
 argument.
 Do constants need messages? They don't --- but you can pass in arbitrary
 arguments when defining a node, and if they're not recognized by the node,
 they will just sit in the state record for all to see.
 This is actually a useful feature, as we'll discover later when we look
 at node tags.
\end_layout

\begin_layout Standard
Now, what is the point of this whole Hello World exercise? Actually, there
 isn't one.
 As I said before, TDL isn't really meant for writing Hello World programs.
 If we want to see something interesting, we should go beyond one node,
 and make us a 
\emph on
tree
\emph default
.
\end_layout

\begin_layout Section
Our first 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 tree
\begin_inset LatexCommand \label{sec:Our-first-"real"}

\end_inset


\end_layout

\begin_layout Standard
Nodes can be connected together into a tree structure.
 If you've already read about or seen something of MeqTrees, then you'll
 know that the point of a tree is to evaluate a mathematical expression.
 Any expression can be represented by a tree.
 For example, the expression 
\end_layout

\begin_layout Standard
\begin_inset Formula \[
f=\alpha\sin(bx+cy+1)\]

\end_inset


\end_layout

\begin_layout Standard
can be represented by the tree in Figure\InsetSpace ~

\begin_inset LatexCommand \ref{1-exprtree}

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Caption
\begin_inset LatexCommand \label{1-exprtree}

\end_inset

An expression tree.
\end_layout

\begin_layout Standard
\align center
\begin_inset External
	template RasterImage
	filename 1-treediagram.eps
	scale 50

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
An expression tree
\begin_inset Foot
status collapsed

\begin_layout Standard
MeqTrees are not quite 
\emph on
trees
\emph default
 in the pedantic sense, since we allow a child to be shared between multiple
 parents, and a tree --- in the conventional definition of graph theory
 --- doesn't.
 The correct term for the sort of structures created in MeqTrees is a 
\emph on
directed acyclic graph
\emph default
.
 You will agree that it doesn't quite roll off the tongue like 
\begin_inset Quotes eld
\end_inset

tree
\begin_inset Quotes erd
\end_inset

 does.
 
\end_layout

\end_inset

 has the following features:
\end_layout

\begin_layout Itemize
nodes can have a parent-child relationship, indicated by connections on
 the diagram.
 
\emph on
Parent 
\emph default
nodes are shown below their 
\emph on
child
\emph default
 nodes.
 
\end_layout

\begin_layout Itemize

\emph on
leaf nodes
\emph default
 are the nodes at the top having no children.
 A leaf node represents an atomic component of an expression, such as a
 constant (
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

, in this example) or a parameter (
\begin_inset Formula $\alpha,b,x,c,y$
\end_inset

).
 
\end_layout

\begin_layout Itemize

\emph on
functional nodes
\emph default
 have children.
 A functional node evaluates some kind of a mathematical function on the
 result(s) of its children, as determined by its 
\emph on
class
\emph default
.
 In this diagram we see instances of add, multiply, and sine classes.
 
\end_layout

\begin_layout Itemize
a 
\emph on
root node
\emph default
 has no parents, its result is the result of the expression (
\emph on
f
\emph default
, in this case).
 Note that 
\emph on
f
\emph default
 here happens to be a multiplication node.
 Note that we can choose to view any node as a 
\begin_inset Quotes eld
\end_inset

root
\begin_inset Quotes erd
\end_inset

 node, the result of which is determined by its 
\emph on
subtree
\emph default
 --- the tree above it.
 
\end_layout

\begin_layout Standard
Given a tree, it is very straightforward to evaluate its result algorithmically,
 by starting at the leaf nodes, and propagating their values through to
 the parents.
 The power of MeqTrees lies in the fact that practically any expression
 can be represented by a tree --- this is only limited by the availability
 of node classes for particular mathematical operations --- and most tastes
 are catered for.
\end_layout

\begin_layout Subsection
Defining trees
\end_layout

\begin_layout Standard
To implement the tree for our expression, we need to define multiple nodes,
 and somehow specify who is a child of whom.
 But let's start at the top of the tree, and define the leaf nodes first:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def _define_forest (ns,**kwargs):
\end_layout

\begin_layout Standard

  # this defines a leaf node named "alpha" of class Meq.Constant,    
\end_layout

\begin_layout Standard

  # initialized with the given value   
\end_layout

\begin_layout Standard

  # (i.e.
 the Fine Structure Constant, in appropriate units)
\end_layout

\begin_layout Standard

  ns.alpha << Meq.Constant(value=297.61903062068177); 
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This defines an 
\begin_inset Quotes eld
\end_inset

alpha
\begin_inset Quotes erd
\end_inset

 node as a constant with the given value.
 It would be quite tiresome if we always had to define constants in such
 a roundabout way, so TDL provides a shortcut:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.b << 1;   
\end_layout

\begin_layout Standard

  ns.c << 1;   
\end_layout

\begin_layout Standard

  ns.x << 1;   
\end_layout

\begin_layout Standard

  ns.y << 1; 
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, instead of creating a node definition, we simply give a numeric value,
 and bind it to a node stub via the 
\family typewriter
<<
\family default
 operator.
 This is exactly equivalent to defining a 
\family typewriter
MeqConstant
\family default
 the verbose way.
\end_layout

\begin_layout Standard
Next, we want to define a parent node to compute the 
\begin_inset Formula $bx$
\end_inset

 product.
 Multiplication is done by the 
\family typewriter
MeqMultiply
\family default
 node, so we have to define one and tell it that its childen are 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

.
 This is easily done:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.bx << Meq.Multiply(ns.b,ns.x); 
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
To specify a node's children, we simply pass the node stubs 
\family typewriter
ns.b
\family default
 and 
\family typewriter
ns.x
\family default
 as (unnamed) arguments to the node definition call.
 In fact, there's an even easier way:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.cy << ns.c * ns.y; 
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
TDL redefines Python's 
\begin_inset Quotes eld
\end_inset


\family typewriter
*
\family default

\begin_inset Quotes erd
\end_inset

 operator so that when it is used with node stubs, it automatically produces
 a definition for a 
\family typewriter
MeqMultiply
\family default
 node! The same applies to 
\family typewriter
+
\family default
, 
\family typewriter
-
\family default
 (both subtraction and unary negation), 
\family typewriter
/
\family default
, 
\family typewriter
%
\family default
 (modulo), and the built-in 
\family typewriter
abs()
\family default
 function.
 This works for single operators and whole expressions, and makes it quite
 easy to define trees for simple arithmetic.
 E.g.
 we could then say:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.sum << ns.bx + ns.cy + 1; 
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
to automatically define a 
\family typewriter
MeqAdd
\family default
 node (two, in fact, since two additions are being done), and even another
 implict
\family typewriter
 MeqConstant
\family default
 node to represent the 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

.
 We could have even rewritten the whole thing as:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.sum << ns.b*ns.x + ns.c*ns.y + 1; 
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
A compound expression like this has to implicitly define some intermediate
 nodes (e.g.
 for the 
\begin_inset Formula $bx$
\end_inset

 and 
\begin_inset Formula $cy$
\end_inset

 products).
 In the meantime, we've only explicitly named the 
\begin_inset Quotes eld
\end_inset

sum
\begin_inset Quotes erd
\end_inset

 node.
 Since every node must have a name, TDL will automatically generate names
 for the intermediate nodes.
 If you run the 
\family typewriter
Intro1/demo1-first-tree.py
\family default
 script in the browser, and open up the Trees view (starting with 
\family sans
Root nodes
\family default
) on the left, you'll see these auto-generated names show up.
\end_layout

\begin_layout Standard
Don't get carried away though, automatic definition only works for basic
 arithmetic.
 To compute the sine, we need to define a 
\family typewriter
MeqSin
\family default
 node the hard way:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.sin << Meq.Sin(ns.sum);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of course, Python provides a 
\family typewriter
math.sin()
\family default
 function for computing sines, but it would be a mistake to try to use it
 here.
 It's important to always realize that
\end_layout

\begin_layout Standard
\align center

\series bold
TDL does not compute!!!
\end_layout

\begin_layout Standard
That is, the actual taking of the sine happens later, 
\emph on
on the kernel side,
\emph default
 when we evaluate the tree.
 Over on the TDL side, we're simply defining a sine node to perform this
 operation.
 This is why the built-in 
\family typewriter
math.sin
\family default
 is inappropriate.
 If you say something like
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.sin << math.sin(ns.sum);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
...you'll get back a Python error, since it can't compute the sine of a node
 stub object.
 On the other hand, you can always say things like:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.foo << math.sin(1);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will evaluate 
\begin_inset Formula $sin(1)$
\end_inset

 using Python, the result of which is a numeric value --- which then hits
 the 
\family typewriter
<<
\family default
 operator and gets turned into a 
\family typewriter
MeqConstant
\family default
 definition.
\end_layout

\begin_layout Standard
Getting back to our tree, we finally need to define the root node, 
\begin_inset Quotes eld
\end_inset

f
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.f << ns.alpha * ns.sin;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
or we could roll the sine and the product into a single statement:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.f << ns.alpha * Meq.Sin(ns.sum)
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
or even roll up the whole tree into a single statement:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.f << ns.alpha*Meq.Sin(ns.b*ns.x+ns.c*ns.y+1);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
You'll note that here we're applying the multiplication operator 
\begin_inset Quotes eld
\end_inset


\family typewriter
*
\family default

\begin_inset Quotes erd
\end_inset

 to a node stub (
\family typewriter
ns.alpha
\family default
) and a node defintion (
\family typewriter
Meq.Sin()
\family default
).
 TDL recognizes this kind of thing too, and automatically defines an intermediat
e node for the sine.
\end_layout

\begin_layout Standard
This completes our 
\family typewriter
_define_forest()
\family default
 function, now it's time to see some results.
\end_layout

\begin_layout Subsection
Evaluating trees
\end_layout

\begin_layout Standard
Now that we've put together our first tree, how do we get MeqTrees to compute
 the result? We have to tell the kernel to evaluate the tree.
 This is called 
\emph on
executing the tree
\emph default
, and is a completely separate step from defining the tree.
\begin_inset Foot
status open

\begin_layout Standard
The term 
\emph on
running
\emph default
 a tree is occasionally used in place of 
\emph on
executing
\emph default
.
 To most programmers, the two words mean pretty much the same.
 We prefer to 
\emph on
execute
\emph default
 our trees, so as not to confuse it with 
\emph on
running
\emph default
 TDL scripts (which only 
\emph on
define
\emph default
 trees.)
\end_layout

\end_inset

 Oftentimes, you will run a TDL script to define a tree, and then reevaluate
 that tree many times under different conditions.
\end_layout

\begin_layout Standard
To execute the tree, we need to add an extra bit of code to our script:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

# at top of file
\end_layout

\begin_layout Standard

from Timba.Meq import meq
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

# ...and somewhere else
\end_layout

\begin_layout Standard

def _test_forest (mqs, parent):
\end_layout

\begin_layout Standard

  domain = meq.domain(1,10,1,10);
\end_layout

\begin_layout Standard

  cells = meq.cells(domain,num_freq=10, num_time=11);
\end_layout

\begin_layout Standard

  request = meq.request(cells);
\end_layout

\begin_layout Standard

  result = mqs.execute('f',request); 
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Without going into details (of which there will be more than enough later),
 this function puts together a 
\emph on
request
\emph default
 object, and (with the final statement) sends it to a node of our tree,
 in this case 
\begin_inset Quotes eld
\end_inset

f
\begin_inset Quotes erd
\end_inset

 (it is also perfectly all right to send the request to any node --- not
 just the root node --- so as to evaluate its subtree separately.) On the
 kernel side, the request will be passed up the tree to the leaf nodes,
 telling them to return their values to their parents, telling the parents
 to compute their functions and return the results to 
\emph on
their
\emph default
 parents, and so on all the way back to the root node.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Caption
\begin_inset LatexCommand \label{1-execmenu}

\end_inset

The script Exec menu.
\end_layout

\begin_layout Standard
\align center
\begin_inset External
	template RasterImage
	filename 1-tdl-exec-menu.png.eps
	rotateAngle 270
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you may have guessed, 
\family typewriter
_test_forest()
\family default
 is another one of these predefined function names.
 How do we invoke this function? If you load and run the 
\family typewriter
Intro1/demo1-first-tree.py
\family default
 script in the browser, you'll note a button labelled 
\family sans
Exec
\family default
 at the top of the script editor window (There's actually two redundant
 buttons --- the second one is labelled 
\family sans
TDL Exec
\family default
 and is situated somewhat higher.
 The second button is convenient when you've hidden the editor window.) Pressing
 this button pops open a menu (see Figure\InsetSpace ~

\begin_inset LatexCommand \ref{1-execmenu}

\end_inset

) containing a 
\begin_inset Quotes eld
\end_inset

test forest
\begin_inset Quotes erd
\end_inset

 item.
 Clicking on this item will cause the browser to call our 
\family typewriter
_test_forest()
\family default
 function.
 Basically, any time the browser loads a script with a 
\family typewriter
_test_forest()
\family default
 function, it will place a link to it into the 
\family sans
Exec
\family default
 menu.
 Other predefined names are also recognized: we'll see more of them later
 on.
\end_layout

\begin_layout Subsection
Results & Bookmarks
\end_layout

\begin_layout Standard
Now, clicking on the 
\begin_inset Quotes eld
\end_inset

test forest
\begin_inset Quotes erd
\end_inset

 item was probably not very satisfying.
 You may have seen a message flash by to the effect that 
\begin_inset Quotes eld
\end_inset

tree has executed successfully
\begin_inset Quotes erd
\end_inset

, but that's all.
\end_layout

\begin_layout Standard
How do we see the result of our calculation? Actually, this isn't something
 you often need to do in real life, so the browser doesn't try to thrust
 it in your face.
 Usually you're more interested in having the result written out somewhere
 (e.g.
 to an AIPS++ Measurement Set.) On the other hand, even then one would still
 like to see something --- some intermediate results for example --- if
 only to verify that the tree is acting as expected, or to keep track of
 the data going by.
 These can often be far more interesting than the final result itself.
 
\end_layout

\begin_layout Standard
In fact, MeqTrees goes a lot further than any software system (arguably,
 all the way), by making available the result of 
\emph on
each and every node
\emph default
 --- effectively, each and every intermediate calculation.
 These can be examined by clicking around in the 
\family sans
Trees
\family default
 view, as we'll see somewhat later.
 Of course, the result of each and every node is way more information than
 you'll ever need (unless you're debugging a tree that acts funny.) It's
 far more likely that there's only a handful of 
\begin_inset Quotes eld
\end_inset

interesting
\begin_inset Quotes erd
\end_inset

 nodes that you want to look at.
 For fast access to these, a TDL script can define one or more 
\emph on
bookmarks
\emph default
, which show up in the 
\family sans
Bookmarks
\family default
 menu at the top of the screen.
\end_layout

\begin_layout Standard
Now load up 
\family typewriter
Intro1/demo1-first-tree.py
\family default
 if you haven't already done so, and run the tree by clicking on the 
\begin_inset Quotes eld
\end_inset

test forest
\begin_inset Quotes erd
\end_inset

 item in the 
\family sans
Exec
\family default
 drop-down menu.
 Access the 
\family sans
Bookmarks
\family default
 menu, and click on 
\begin_inset Quotes eld
\end_inset


\family sans
result of 'f'
\family default

\begin_inset Quotes erd
\end_inset

.
 This is a bookmark to the root node of our tree.
 You'll see a panel show up in the 
\family sans
Gridded Viewers
\family default
 pane on the right.
 Depending on how recent your installation of MeqTrees is --- the viewer
 widgets are always a work in progress --- this will either be a large green
 box (indicating a constant value), or a simple message.
 In any case you should be able to see the answer given by our tree: 
\end_layout

\begin_layout Standard
\align center

\size large
42.
\end_layout

\begin_layout Section
How to ask the right question
\end_layout

\begin_layout Standard
At this point you may be feeling somewhat underwhelmed, having gone through
 a lot of trouble for such a seemingly simple answer.
 But if you still remember your classics (???), you should immediately recognize
 that we simply don't know how to ask the right question yet.
\end_layout

\begin_layout Standard
Fortunately, formulating the right question in MeqTrees is not very difficult.
 The thing is, if you're only interested in scalar calculations, you don't
 really need to build trees --- MathLab, or a Python prompt, or even a calculato
r is way more convenient.
 MeqTrees was really designed to work with functions, not scalars.
\end_layout

\begin_layout Subsection
A world of functions
\end_layout

\begin_layout Standard
Most things we deal with in real life (insofar as radioastronomy and such
 can be considered 
\begin_inset Quotes eld
\end_inset

real life
\begin_inset Quotes erd
\end_inset

) are functions of something or other.
 A typical astronomical image gives flux or brightness a function of 
\begin_inset Formula $x,y$
\end_inset

 (and perhaps 
\begin_inset Formula $\nu$
\end_inset

 --- frequency).
 An interferometer observes correlations as functions of time 
\begin_inset Formula $t$
\end_inset

 and frequency 
\begin_inset Formula $\nu$
\end_inset

.
 Antenna gains can be complex functions of 
\begin_inset Formula $t,\nu$
\end_inset

.
 Ionospheric phase (as seen by one antenna) is a function of direction and
 
\begin_inset Formula $\nu$
\end_inset

.
 
\end_layout

\begin_layout Standard
Now consider our original expression:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
f=\alpha\sin(bx+cy+1)\]

\end_inset


\end_layout

\begin_layout Standard
If we make 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 functions of time and frequency, then 
\begin_inset Formula $f$
\end_inset

 itself becomes a function of time and frequency:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
f(t,\nu)=\alpha\sin(bx(t,\nu)+cy(t,\nu)+1)\]

\end_inset


\end_layout

\begin_layout Standard
Can we make a tree to compute 
\begin_inset Formula $f$
\end_inset

 as a function of 
\begin_inset Formula $t,\nu$
\end_inset

? 
\emph on
We already have, pretty much.

\emph default
 Every node in a tree can produce a function instead of a scalar, and the
 rest will compute the 
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

 result, regardless.
 In fact, scalars are just special cases of constant functions.
\end_layout

\begin_layout Subsection
Representing functions
\end_layout

\begin_layout Standard
Of course a function in the mathematical sense is usually defined over a
 continuous --- and thus infinite --- space.
 The conventional way to represent functions in numerical computing, and
 the one used by MeqTrees, is to limit ourselves to a finite 
\emph on
domain
\emph default
 (e.g.
 
\begin_inset Formula $[t_{begin},t_{end}]\times[\nu_{begin},\nu_{end}]$
\end_inset

 ), make a 
\emph on
gridding
\emph default
 of that domain (
\begin_inset Formula $\{ t_{1}...t_{n}\},\{\nu_{1}...\nu_{m}\}$
\end_inset

), and then represent a function 
\begin_inset Formula $f(t,v)$
\end_inset

 by an 
\begin_inset Formula $n\times m$
\end_inset

 array of samples 
\begin_inset Formula ${\{ f}_{ij}=f(t_{i},\nu_{j})\}$
\end_inset

.
 This of course applies to an arbitrary number of axes, not just two.
\begin_inset Foot
status open

\begin_layout Standard
MeqTrees supports up to 8 axes at a time, the meaning of which may be (re)define
d in an arbitrary way.
 Frequency and time, being the two most popular ones, are the default for
 axis 1 and 2, and so will be used in most of our examples.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To see this in action, load up 
\family typewriter
Intro1/demo2-improved-tree.py
\family default
, run 
\begin_inset Quotes eld
\end_inset

test forest
\begin_inset Quotes erd
\end_inset

, and look at the bookmarks.
\end_layout

\begin_layout Subsection
So what's a function look like?
\end_layout

\begin_layout Standard
This script actually builds two trees --- one rooted at node 
\begin_inset Quotes eld
\end_inset

f
\begin_inset Quotes erd
\end_inset

, the other at 
\begin_inset Quotes eld
\end_inset

f1
\begin_inset Quotes erd
\end_inset

.
 If you load up the 
\begin_inset Quotes eld
\end_inset

f
\begin_inset Quotes erd
\end_inset

 bookmark, you should see something like Figure\InsetSpace ~

\begin_inset LatexCommand \ref{1-function}

\end_inset

 (and if you don't, you've probably forgotten to click on 
\begin_inset Quotes eld
\end_inset

test forest
\begin_inset Quotes erd
\end_inset

.)
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Caption
\begin_inset LatexCommand \label{1-function}

\end_inset

Viewing a function in the browser
\end_layout

\begin_layout Standard
\align center
\begin_inset External
	template RasterImage
	filename 1-improved-tree.png.eps
	rotateAngle 270
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, if you look at the plot, you will see that it displays ``f'' as a two-dimen
sional image in frequency and time.
 How did this time/frequency dependence come about? Look at the top of the
 script, and you'll see that the 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

y
\begin_inset Quotes erd
\end_inset

 nodes are no longer defined as constants:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.x << Meq.Time;   
\end_layout

\begin_layout Standard

  ns.y << Meq.Freq; 
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
MeqTime
\family default
 node returns time as a function of time, the 
\family typewriter
MeqFreq
\family default
 node likewise (note that when defining a node with no arguments, the 
\family typewriter
()
\family default
 is not necessary --- but we could have used 
\family typewriter
Meq.Time()
\family default
 just as well.) So we have just defined
\end_layout

\begin_layout Standard
\begin_inset Formula \[
x(t)\equiv t,\; y(\nu)\equiv\nu\]

\end_inset

 
\end_layout

\begin_layout Standard
Looking at the rest of the tree, the expression for 
\begin_inset Formula $f$
\end_inset

 then becomes
\end_layout

\begin_layout Standard
\begin_inset Formula \[
f(t,\nu)=\alpha\sin(t\cos(2\nu))\]

\end_inset


\end_layout

\begin_layout Standard
Note that it's only the 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

y
\begin_inset Quotes erd
\end_inset

 nodes where we define a time/frequency dependence --- it propagates through
 the rest of the tree auto-magically.
 For comparison, the tree rooted at 
\begin_inset Quotes eld
\end_inset

f1
\begin_inset Quotes erd
\end_inset

 is defined as
\end_layout

\begin_layout Standard
\begin_inset Formula \[
f_{1}=\alpha\sin(x_{1}\cos({2y}_{1})),\]

\end_inset


\end_layout

\begin_layout Standard
with 
\begin_inset Formula $x_{1}=y_{1}=1$
\end_inset

.
 If you look at the bookmark for 
\begin_inset Quotes eld
\end_inset

f1
\begin_inset Quotes erd
\end_inset

, you'll see a constant result as previously.
\end_layout

\begin_layout Standard
On a side note, note this syntax:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.f1 << a*Meq.Sin((ns.x1<<1)*Meq.Cos(2*(ns.y1<<1)))
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This takes advantage of the fact that the 
\family typewriter
<<
\family default
 operator returns the node stub itself as a result.
 This lets us name and define nodes directly inside an expression.
 Thus the line above is just a more concise version of the following piece
 of code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.x1 << 1;
\end_layout

\begin_layout Standard

  ns.y1 << 1;
\end_layout

\begin_layout Standard

  ns.f1 << a*Meq.Sin(ns.x1*Meq.Cos(2*ns.y1))
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Intermezzo: assigning nodes to variables
\end_layout

\begin_layout Standard
You may have noticed one other interesting twist in this script.
 At the start of 
\family typewriter
_define_forest()
\family default
, we define the 
\begin_inset Quotes eld
\end_inset

alpha
\begin_inset Quotes erd
\end_inset

 node as follows:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  a = ns.alpha << 297.61903062068177;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Recall that the 
\family typewriter
<<
\family default
 operator has a return value, namely the node stub itself.
 The statement above defines the node stub 
\begin_inset Quotes eld
\end_inset

alpha
\begin_inset Quotes erd
\end_inset

, and assigns it to the Python variable 
\family typewriter
a
\family default
.
 We can then reuse 
\family typewriter
a
\family default
 anywhere in place of 
\family typewriter
ns.alpha
\family default
, in particular here:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.f1 << a*Meq.Sin((ns.x1<<1)*Meq.Cos(2*(ns.y1<<1)))
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we'll see later, this is a very useful feature of TDL, but it can cause
 some confusion to beginners, as I saw myself during our workshops.
 In particular,
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
a = Meq.Constant(value=0);
\end_layout

\begin_layout Standard
may look like it produces a node, but in fact it doesn't
\begin_inset Foot
status open

\begin_layout Standard
What it actually does will be made clearer in Chapter\InsetSpace ~

\begin_inset LatexCommand \ref{cha:The-Pyton-Perspective}

\end_inset

.
\end_layout

\end_inset

, no more than
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
Meq.Constant(value=0);
\end_layout

\begin_layout Standard
alone by itself does.
 
\emph on
To define a real node, you must always do two things: make a node stub,
 and bind it to a definition with 
\family typewriter
<<
\family default
.
\end_layout

\begin_layout Subsection
Looking at other results
\end_layout

\begin_layout Standard
The browser provides a number of ways of looking at nodes and results.
 These are provided by different 
\emph on
viewer plugins
\emph default
.
 The plots we accessed via the bookmarks were produced by the Result Plotter
 plugin.
 A more system-level view can be obtained via the Record Browser.
 If you left-click on a node in the 
\family sans
Trees
\family default
 view, it brings up a Record Browser for that node's 
\emph on
state record
\emph default
.
 If you right-click on a node, you can select a different viewer via the
 context menu.
\end_layout

\begin_layout Standard
The state record tells you more than you ever want to know about a node.
 For now, we're only interested in a field called 
\family sans
cache.result
\family default
.
 If you find node 
\begin_inset Quotes eld
\end_inset

y
\begin_inset Quotes erd
\end_inset

 and bring up its state record, then expand the 
\family sans
cache.result
\family default
 field, you should see something like Figure\InsetSpace ~

\begin_inset LatexCommand \ref{1-cacheresult}

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Caption
\begin_inset LatexCommand \label{1-cacheresult}

\end_inset

Looking at a cached result
\end_layout

\begin_layout Standard
\align center
\begin_inset External
	template RasterImage
	filename 1-improved-tree-cache-result.png.eps
	rotateAngle 270
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The browser makes it so easy to examine the tree that it's easy to forget
 one important thing: what you're looking at is just a Python representation
 of something that's going on inside the kernel.
 When you click on a node, the browser sends a message to the kernel requesting
 that node's state, and receives a snapshot of the state in reply.
 We'll return to this distinction later on.
\end_layout

\begin_layout Subsubsection
Axes of variability
\end_layout

\begin_layout Standard
The thing to note in Figure\InsetSpace ~

\begin_inset LatexCommand \ref{1-cacheresult}

\end_inset

 is that the 
\family sans
value
\family default
 field of the result is a 
\begin_inset Formula $1\times200$
\end_inset

 array.
 This is because the 
\begin_inset Quotes eld
\end_inset

y
\begin_inset Quotes erd
\end_inset

 node depends only on frequency, which is the second axis by default.
 In this case we say that the result has a single axis of variability, frequency.
 If you look at the 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 node, its value will be a 
\begin_inset Formula $100\times1$
\end_inset

 array (or a vector of length 100, which is really the same thing as far
 as MeqTrees are concerned), indicating that time (the first axis) is the
 only axis of variability.
 If you click through the 
\family sans
cache.result
\family default
s of the 
\emph on
parents
\emph default
 of 
\begin_inset Quotes eld
\end_inset

y
\begin_inset Quotes erd
\end_inset

, you'll see the same 
\begin_inset Formula $1\times200$
\end_inset

 dimensions, until we get to the 
\begin_inset Quotes eld
\end_inset

multiply...
\begin_inset Quotes erd
\end_inset

 node upstream, where the 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 and the 
\begin_inset Quotes eld
\end_inset

y
\begin_inset Quotes erd
\end_inset

 branches come together.
 The value of this node is a 
\begin_inset Formula $100\times200$
\end_inset

 array, indicating a that both time and frequency are now axes of variability.
\end_layout

\begin_layout Standard
What this illustrates is that MeqTrees is very economical about representing
 functions --- if a node's result has no variability along a particular
 axis, its size along that axis will be 1.
 But results with different axes of variability will be combined together
 and yield the right answer with the right number of axes.
\end_layout

\begin_layout Standard
If you've ever done any numerical code of your own, you've probably written
 endless 
\family typewriter
for
\family default
 loops iterating over times, frequencies, coordinates, and whatnot.
 MeqTrees takes care of all of this for you, and even lets you go back and
 painlessly introduce an extra dimension somewhere at the start of the calculati
on --- which in normal numerical code would require restructuring of every
 subsequent loop.
\end_layout

\begin_layout Subsection
Domains, Grids, Cells
\end_layout

\begin_layout Standard
Where did the magical sizes of 100 and 200 for the time and frequency axes
 comes from? From this bit of code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def _test_forest (mqs, parent):
\end_layout

\begin_layout Standard

  domain = meq.domain(10,20,0,10);
\end_layout

\begin_layout Standard

  cells = meq.cells(domain,num_freq=200, num_time=100);
\end_layout

\begin_layout Standard

  request = meq.request(cells);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first line constructs a 
\emph on
domain
\emph default
 object, specifying the domain (in 
\begin_inset Formula $t,\nu$
\end_inset

) over which we want to evaluate the tree.
 In this case 
\begin_inset Formula $t$
\end_inset

 goes from 0 to 10, and 
\begin_inset Formula $\nu$
\end_inset

 from 10 to 20.
 The second line constructs a 
\emph on
cells
\emph default
 object.
 A cells consists of a domain and a gridding.
 This particular invocation makes a regular grid of 100 points in 
\begin_inset Formula $t$
\end_inset

 and 200 points in 
\begin_inset Formula $\nu$
\end_inset

, for the given domain.
\begin_inset Foot
status open

\begin_layout Standard
In case you're wondering, it is also possible to specify irregular grids.
 And of course a domain need not be in frequency and time.
 We'll see examples of this later.
\end_layout

\end_inset

 Finally, we put the cells into a 
\emph on
request
\emph default
 object, which will then be passed to the root node of our tree.
\end_layout

\begin_layout Subsection
Who knows what
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Who knows what
\begin_inset Quotes erd
\end_inset

 is a very important question in software design.
 In a well-designed system, each component should have the minimum information
 necessary to get its job done.
 If this 
\begin_inset Quotes eld
\end_inset

segregation of information
\begin_inset Quotes erd
\end_inset

 is not lovingly maintained, you'll see various assumptions creep in where
 they don't belong, each one undermining the flexibility of the final system.
\end_layout

\begin_layout Standard
We'll be touching on this question again later; in the meantime, let's review
 who in MeqTrees knew what in the examples we've looked at.
\end_layout

\begin_layout Subsubsection
The user (i.e., ourselves)
\end_layout

\begin_layout Standard
We know all --- or do we? Of course we know the script that built our trees,
 since we wrote it.
 On the other hand, somebody else could have written the script for us.
 We can then choose to treat it as a black box.
 The only thing we, the users, need to know then is to click on 
\begin_inset Quotes eld
\end_inset

test forest
\begin_inset Quotes erd
\end_inset

 to run the tree, and click on 
\family sans
Bookmarks
\family default
 to look at results.
 If we're really interested in the internal structure of the tree, we can
 browse it in the 
\family sans
Trees
\family default
 pane, and click on various nodes to discover everything there is to know
 about them.
\end_layout

\begin_layout Standard
There's an important principle here that was designed into MeqTrees from
 the very beginning --- the user is allowed to know everything.
 Practically all the system internals are completely transparent and can
 be viewed from the browser.
 On the other hand, for users who just want a broad overview, there's an
 extensive system of visualizations and bookmarks to provide just that.
\end_layout

\begin_layout Subsubsection
The tree
\end_layout

\begin_layout Standard
The tree, in fact, knows nothing, because the tree, as a separate entity,
 is practically non-existent.
 A tree is only a collection of nodes that happen to be connected.
 All the knowledge necessary for running the tree resides in the individual
 nodes.
 This is called the 
\emph on
locality principle
\emph default
.
 
\end_layout

\begin_layout Subsubsection
The nodes
\end_layout

\begin_layout Standard
What does a node know?
\end_layout

\begin_layout Itemize
It knows its class, i.e.
 what sort of operation it has to perform
\end_layout

\begin_layout Itemize
It knows its children
\end_layout

\begin_layout Itemize
It has some knowledge of its parents (mostly for housekeeping purposes such
 as caching)
\end_layout

\begin_layout Itemize
It knows its 
\emph on
state
\emph default
, which can influence its behaviour
\end_layout

\begin_layout Standard
What a node 
\emph on
doesn't
\emph default
 know:
\end_layout

\begin_layout Itemize
It doesn't (usually) know the type of its children.
 All it knows is that they return some kind of result.
\end_layout

\begin_layout Itemize
It doesn't know anything about the tree, apart from its children or parents.
\end_layout

\begin_layout Itemize
It doesn't know anything about domains or grids.
 The domain and grid comes up in the request from its parent(s).
 It can make use of that information while it processes the request, but
 it doesn't usually retain it.
\end_layout

\begin_layout Section*
Recap
\end_layout

\begin_layout Standard
Here's a short review of what we learned in this chapter:
\end_layout

\begin_layout Itemize
MeqTrees consists of a fast kernel for doing the real work (building and
 running trees), and a graphical browser for looking at things.
\end_layout

\begin_layout Itemize
You build trees via TDL scripts.
 TDL scripts define the structure of trees.
 TDL is Python with some syntactic sugar thrown in.
\end_layout

\begin_layout Itemize
The purpose of a tree is (usually) to evaluate some mathematical expression.
 Most real-life expression will be functions of something or other, e.g.
 time, frequency, position, etc.
 A tree provides an efficient way to evaluate such functions 
\begin_inset Quotes eld
\end_inset

in bulk
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
You 
\begin_inset Quotes eld
\end_inset

run
\begin_inset Quotes erd
\end_inset

 a tree by giving it a domain and a gridding (
\begin_inset Quotes eld
\end_inset

cells
\begin_inset Quotes erd
\end_inset

), and it returns the value of the expression over that grid.
\end_layout

\begin_layout Itemize
With the browser, you can look at trees in great detail, and visualize everythin
g.
\end_layout

\begin_layout Chapter
Growing Forests
\end_layout

\begin_layout Standard
The previous chapter's examples don't really answer the fundamental question
 of 
\emph on
What's the point?
\emph default
 
\end_layout

\begin_layout Standard
blah blah lots of trees blah blah.
 Basically some subset of the workshop demos.
 This may even grow into several chapters.
\end_layout

\begin_layout Chapter
The Python Perspective
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \label{cha:The-Pyton-Perspective}

\end_inset

This chapter aims to provide an in-depth description of how TDL does what
 it does, and how to make it do what you want.
 As a way of describing trees, TDL is (I hope) natural enough that you can
 get a very long way without any real idea of what's happening under the
 hood.
 The same of course goes for Python itself, or any other high-level programming
 language.
 
\end_layout

\begin_layout Standard
To be really proficient in a language, however, requires a solid understanding
 of the basics.
 What really happens when you define a node? What's the difference between
 a node and a Python variable? What happens when you pass a node to a function?
 What does the node scope 
\emph on
really
\emph default
 do, and why should you care? 
\end_layout

\begin_layout Standard
If you can answer these questions, what have you gained? At least a few
 things:
\end_layout

\begin_layout Itemize
You'll think of faster ways to accomplish the same result, and with fewer
 errors
\end_layout

\begin_layout Itemize
Obscure error messages will cease to be so mysterious
\end_layout

\begin_layout Itemize
You'll find your scripts to be a lot more reusable down the line
\end_layout

\begin_layout Itemize
You'll have a far clearer idea of how frameworks like Meow work, and you'll
 be able to employ them better
\end_layout

\begin_layout Itemize
You may even make your own frameworks and modules.
\end_layout

\begin_layout Standard
All in all, you'll find yourself doing less actual work in TDL while putting
 it to much better use, leaving you with more time for getting interesting
 results!
\end_layout

\begin_layout Standard
And there's another good reason.
 Because 
\emph on
TDL is Python
\emph default
, getting adept at TDL will automatically make you more proficient in Python,
 thus honing skills which can be quite useful in the world outside of MeqTrees
 (as much as we hate to admit that there is such a place...)
\end_layout

\begin_layout Standard
As a final warning, this chapter will certainly venture into the touchy
 territory of 
\emph on
good
\emph default
 (or even --- ambitiously --- best) 
\emph on
practices
\emph default
.
 This is a subject that is difficult to cover without hitting the occasional
 preachy note.
 As the person who is principally to blame for TDL in the first place, and
 having done probably more work in it --- and, crucially, having made more
 mistakes --- than anyone else up till now, I do feel somewhat qualified
 to preach on the subject.
 On the other hand, in a project that has always developed through something
 of a creative anarchy, there's not much place for gospel.
 Besides, as a language TDL is certainly too young for an anywhere-near-complete
 body of best practices to have emerged.
 So please feel free to do things differently and make your own mistakes
 (try not to repeat too many of mine, though) and refine your own practices.
 In the words of Captain Barbossa, 
\begin_inset Quotes eld
\end_inset

the [Pirate] Code is more what you'd call `guidelines' than actual rules.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection*
Reading the Python class documentation
\end_layout

\begin_layout Standard
The Python classes responsible for making TDL work reside in the 
\family typewriter
Timba.TDLimpl
\family default
 module.
 The classes are called 
\family typewriter
_NodeScope
\family default
, 
\family typewriter
_ClassGen
\family default
, 
\family typewriter
_ClassStub
\family default
, 
\family typewriter
_NodeDef
\family default
 and 
\family typewriter
_NodeStub
\family default
.
 You can find a detailed class reference here:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~
??????????????????????????????
\end_layout

\begin_layout Standard
It's hard to make much sense of the class reference without a basic understandin
g of how the classes work together.
 The latter is supposed to be provided by this chapter.
 After reading this chapter, you can go to the class reference to fill in
 the gaps.
\end_layout

\begin_layout Section
Node scopes, stubs and definitions
\end_layout

\begin_layout Standard
If you recall our Hello World script (
\family typewriter
1-helloworld.py
\family default
), we can see that the 
\begin_inset Quotes eld
\end_inset

tree
\begin_inset Quotes erd
\end_inset

, such as it is, is brought about by this bit of code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def _define_forest (ns,**kwargs):
\end_layout

\begin_layout Standard

  ns.hello_world << Meq.Constant(value=0,message="Hello world!"); 
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, we already know that 
\family typewriter
_define_forest()
\family default
 is a predefined TDL name that the browser looks for when we load the script.
 The 
\emph on
node scope
\emph default
 (
\family typewriter
ns
\family default
) argument is more precisely known as the 
\emph on
global node scope
\emph default
.
 This is a 
\begin_inset Quotes eld
\end_inset

magic
\begin_inset Quotes erd
\end_inset

 object that's created by the browser.
 The purpose of 
\family typewriter
_define_forest() 
\family default
is to populate the global node scope with node definitions, which the browser
 can then pass onto the kernel to construct a tree.
 
\end_layout

\begin_layout Standard
A crucial (for us) feature of Python is that function arguments are always
 passed by reference.
 This means that only one copy of the 
\family typewriter
ns
\family default
 object actually exists, and any manipulations inside 
\family typewriter
_define_forest()
\family default
 are done directly on the original object.
 Likewise, you can pass 
\family typewriter
ns
\family default
 to your own functions, and it will still refer to the same original global
 node scope.
 
\end_layout

\begin_layout Standard
Note that 
\emph on
assignment in Python is not manipulation
\emph default
.
 If your 
\family typewriter
_define_forest()
\family default
 says
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
ns = 0;
\end_layout

\begin_layout Standard
then you haven't done anything to the original node scope object.
 All you've done is disassociate the local (local to 
\family typewriter
_define_forest()
\family default
, that is) 
\family typewriter
ns
\family default
 variable from the node scope object, and associate it with the integer
 
\begin_inset Quotes eld
\end_inset

0
\begin_inset Quotes erd
\end_inset

.
 The original node scope is still out there somewhere, you've simply discarded
 your reference to it.
 Similarly, saying
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
ns1 = ns;
\end_layout

\begin_layout Standard
does not make a new node scope object --- all it does is give you two local
 variables that refer to the same object.
 This is really fundamental to Python, not just TDL.
\end_layout

\begin_layout Standard
The main purpose of the node scope is to allow us to 
\emph on
name
\emph default
 nodes.
 In Python, saying 
\family typewriter
ns.foo
\family default
 means 
\begin_inset Quotes eld
\end_inset

give me the attribute named `foo' of the object referred to by variable
 
\family typewriter
ns
\family default

\begin_inset Quotes erd
\end_inset

.
 An alternative syntax for this operation is 
\family typewriter
getattr(ns,
\emph on
'
\emph default
foo')
\family default
.
 
\begin_inset Quotes eld
\end_inset

Normal
\begin_inset Quotes erd
\end_inset

 Python objects have a fixed set of attributes defined by their class.
 The node scope class redefines the get-attribute operation to do node naming.
 The naming operation works as follows:
\end_layout

\begin_layout Itemize
When you try to get the attribute 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

, it checks if a 
\emph on
node stub
\emph default
 called 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 is already present.
\end_layout

\begin_layout Itemize
If it is, it returns that node stub.
\end_layout

\begin_layout Itemize
If not, then it creates a new
\emph on
 
\emph default
node stub, and returns it.
\end_layout

\begin_layout Standard
Note that, once again, Python works by reference.
 There is only one node stub out there for 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

.
 If you say:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  foo = ns.foo;
\end_layout

\begin_layout Standard

  bar = ns.foo;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
you now have two local variables, 
\family typewriter
foo
\family default
 and 
\family typewriter
bar
\family default
, both referring to the same stub for node 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The node scope class also redefines the 
\family typewriter
[]
\family default
 operation to work in exactly the same way.
 The three expressions
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.foo
\end_layout

\begin_layout Standard

  getattr(ns,'foo')
\end_layout

\begin_layout Standard

  ns['foo']
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
all produce exactly the same result.
 The second and third form allow one twist that the first form doesn't ---
 that is, using 
\emph on
expressions
\emph default
 to 
\begin_inset Quotes eld
\end_inset

compute
\begin_inset Quotes erd
\end_inset

 node names.
 For example,
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  a = 'fo' 
\end_layout

\begin_layout Standard

  ns[a+'o']
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
is a fancy alternative to 
\family typewriter
ns.foo
\family default
.
 I'm sure creative minds can find a great use for this.
\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

Real
\begin_inset Quotes erd
\end_inset

 node scope methods
\end_layout

\begin_layout Standard
Note that node scopes also have a few 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 attributes (more precisely, methods) in the conventional Python sense.
 For example, 
\family typewriter
ns.Subscope()
\family default
 invokes an actual method to create a subscope, instead of creating a node
 stub named 
\begin_inset Quotes eld
\end_inset

Subscope
\begin_inset Quotes erd
\end_inset

.
 Another example is the 
\family typewriter
ns.Search()
\family default
 method, which can be used to search node scopes.
 Both of these operations will be discussed later.
 
\end_layout

\begin_layout Standard
The convention is that all 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 methods of the node scope object have names that start with a capital.
 To see a complete list of these reserved names, you can refer to the class
 documentation.
\end_layout

\begin_layout Standard
In the unlikely event that you actually do mean to make a node stub named
 
\begin_inset Quotes eld
\end_inset

Subscope
\begin_inset Quotes erd
\end_inset

 (and are not worried by the ensuing terminology creep --- but hey, it's
 a free country, presumably), you can always do it via the 
\family typewriter
[]
\family default
 syntax:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns["Subscope"] << Meq.Confusion(message="I've gone bonkers")
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Objects and more objects
\end_layout

\begin_layout Standard
But what 
\emph on
is
\emph default
 a node stub? First of all, remember that 
\emph on
everything in Python is a first-class object
\emph default
.
 So a node stub is an object --- as it happens, of the 
\family typewriter
TDL._NodeStub
\family default
 class.
 We'll study the class in more detail later, in the meantime, the crucial
 question is, what does a node stub really represent? Well, the answer is,
 it represents a 
\emph on
node name
\emph default
.
 The name, by itself, is not yet a complete node --- we have to associate
 it with a 
\emph on
node definition
\emph default
.
\end_layout

\begin_layout Standard
What's a node definition? You guessed it, it's also an object (of the 
\family typewriter
TDL._NodeDef
\family default
 class.) What does a node definition really represent? All the information
 required to create a node, except the name.
 As a minimum, this includes the 
\emph on
node class
\emph default
 (not to be confused with Python classes!
\begin_inset Foot
status open

\begin_layout Standard
Node classes are only known to the MeqTree kernel.
 On the kernel side, they actually correspond to C++ classes.
 On the TDL side, a 
\begin_inset Quotes eld
\end_inset

node class
\begin_inset Quotes erd
\end_inset

 is just a string identifier.
\end_layout

\end_inset

), but it may also contain references to child nodes, and optional arguments.
 Node definition objects are created by calling something like 
\family typewriter
Meq.
\emph on
Classname
\emph default
(...)
\family default
.
 By itself, a definition is not a complete node either.
 The 
\family typewriter
<<
\family default
 operator is how a node stub (i.e.
 the name) meets a defintion and becomes a fully-fledged node.
 
\end_layout

\begin_layout Standard
This is worth a summary:
\end_layout

\begin_layout Itemize
Every MeqTree node needs a name and a definition.
 The latter consists of a node class, (optional) references to child nodes,
 and (optional) keyword arguments.
 
\end_layout

\begin_layout Itemize
The name is unique but the definition isn't.
 In fact, you can define many identical (in all but name) nodes using the
 same definition object.
\end_layout

\begin_layout Itemize
Taken by itself, a node stub like 
\family typewriter
ns.foo
\family default
 is only a 
\begin_inset Quotes eld
\end_inset

potential
\begin_inset Quotes erd
\end_inset

 node --- it's really just a node name, nothing more.
 
\end_layout

\begin_layout Itemize
Likewise, on its own, a node definition object such as that returned by
 
\family typewriter
Meq.Constant()
\family default
 is also only a 
\begin_inset Quotes eld
\end_inset

potential
\begin_inset Quotes erd
\end_inset

 node.
 It is when the two are 
\emph on
bound
\emph default
 together with the 
\family typewriter
<<
\family default
 operator that a complete node emerges.
\end_layout

\begin_layout Itemize
Consequently, you may litter your code with node stubs and node definitions
 that are not bound to anything, and none of these will cause any 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 nodes to be created.
 The following thoroughly useless bit of code creates an empty tree:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

        def _define_forest (ns,**kwargs):  
\end_layout

\begin_layout Standard

          a = ns.foo;
\end_layout

\begin_layout Standard

          b = Meq.Constant();
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
What really happens during binding
\end_layout

\begin_layout Standard
Let's see how Python handles the statement:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
ns.foo << Meq.Constant(value=0);
\end_layout

\begin_layout Standard
First, it evaluates the left-hand side, 
\family typewriter
ns.foo
\family default
.
 It tries to get the 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 attribute of the node scope object, and gets back a node stub object.
\end_layout

\begin_layout Standard
Next, it evaluates the right-hand side.
 Here we have another 
\begin_inset Quotes eld
\end_inset

magic
\begin_inset Quotes erd
\end_inset

 TDL object called 
\family typewriter
Meq
\family default
.

\family typewriter
 
\family default
This is a 
\emph on
node class generator
\emph default
 object (
\family typewriter
TDL._ClassGen
\family default
).
 We'll take a detailed look inside it in a bit.
 In the meantime, the expression 
\family typewriter
Meq.Constant 
\family default
means simply 
\begin_inset Quotes eld
\end_inset

get the attribute named `Constant' of the object referred to by 
\family typewriter
Meq
\family default
.
\begin_inset Quotes erd
\end_inset

 Similarly to how node scopes return node stubs for their attributes, a
 class generator returns a class stub (
\family typewriter
TDL._ClassStub
\family default
) when an attribute is accessed.
 Then, 
\begin_inset Quotes eld
\end_inset


\family typewriter
(value=0)
\family default

\begin_inset Quotes erd
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

treat whatever you got as a function, and call it with a keyword parameter,
 
\family typewriter
value=0
\family default
.
\begin_inset Quotes erd
\end_inset

 The end result of the expression is then whatever the function call returned.
 Which, due to some magic going on inside the class generator and class
 stub objects, happens to be a node definition object specifying a node
 class of 
\family typewriter
MeqConstant
\family default
, with an extra 
\family typewriter
value=0
\family default
 argument.
\end_layout

\begin_layout Standard
Now Python has a node stub object on the left, a node definition on the
 right, and the 
\begin_inset Quotes eld
\end_inset


\family typewriter
<<
\family default

\begin_inset Quotes erd
\end_inset

 operator in between.
 This operator normally means a bitwise shift, but the 
\family typewriter
TDL._NodeStub
\family default
 redefines it to do something else.
 Because of this, Python calls a special method of the node stub object
 (called 
\family typewriter
__lshift__
\family default
, if you want to know), with the node definition as an argument.
 The node stub object then indelibly associates itself with the given definition
, and now contains enough information to be later turned into a 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 node.
 This operation is also called 
\emph on
initializing
\emph default
 a node stub.
\end_layout

\begin_layout Standard
For the sake of illustration, here's an equivalent piece of Python code
 that makes every step explicit:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  node_stub = ns.foo
\end_layout

\begin_layout Standard

  # or equivalently: nodestub = getattr(ns,'foo') 
\end_layout

\begin_layout Standard

  class_stub = Meq.Constant
\end_layout

\begin_layout Standard

  node_def = class_stub(value=0)
\end_layout

\begin_layout Standard

  node_stub << node_def
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Rebinding and reusing nodes
\end_layout

\begin_layout Standard
What happens when you refer to 
\family typewriter
ns.foo
\family default
 again? Of course you get back a reference to the same node stub, which
 has now been initialized.
 We do this all the time when specifying the children of a node.
 In fact, a little-appreciated feature is that node stubs 
\emph on
need not be initialized before use
\emph default
, as long as you remember to initialize them later.
 The following is perfectly legitimate:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.bar << ns.foo + 1;
\end_layout

\begin_layout Standard

  ns.foo << Meq.Constant(value=1);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you omit the second line, you'll get back an error message.
\begin_inset Foot
status open

\begin_layout Standard
In the current version of TDL, this error message says something like 
\begin_inset Quotes eld
\end_inset

child 
\emph on
n
\emph default
 not initialized
\begin_inset Quotes erd
\end_inset

.
 This makes some sense: you have specified 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 to be a child of 
\begin_inset Quotes eld
\end_inset

bar
\begin_inset Quotes erd
\end_inset

, but you forgot to initialize 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

.
 Still, I've noticed that this error tends to confuse people, so I may change
 it to something more lucid in the future.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What about doing 
\family typewriter
<<
\family default
 to an already initialized node stub? This is only allowed if the node definitio
n is the same:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.foo << Meq.Constant(value=1);
\end_layout

\begin_layout Standard

  ns.foo << Meq.Constant(value=1);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
is OK, but 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.foo << Meq.Constant(value=1);
\end_layout

\begin_layout Standard

  ns.foo << Meq.Constant(value=0);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will produce an error.
 Personally, I consider rebinding to be bad practice.
 In some complicated cases, figuring out if a node definition is the same
 or not can be a dicey process, so I'd rather not rely on this feature.
\end_layout

\begin_layout Standard
If you have a function for defining some part of the tree, and you call
 that function repeatedly, you probably want to initialize the nodes only
 once, rather than try to rebind them every time.
 TDL provides two convenient mechanisms for this.
 The first one is the 
\begin_inset Quotes eld
\end_inset


\family typewriter
**
\family default

\begin_inset Quotes erd
\end_inset

 operator.
 This is similar to 
\begin_inset Quotes eld
\end_inset


\family typewriter
<<
\family default

\begin_inset Quotes erd
\end_inset

, but it means 
\begin_inset Quotes eld
\end_inset

only bind if not already bound, otherwise ignore.
\begin_inset Quotes erd
\end_inset

 So something like:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def make_tree_for_foo (ns):
\end_layout

\begin_layout Standard

  return ns.foo ** Meq.Constant(value=1);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
means that 
\family typewriter
ns.foo
\family default
 will be initialized as usual the first time the function is called.
 Subsequent calls will ignore the definition and return the already-initialized
 
\family typewriter
ns.foo
\family default
.
 This is handy for one-line definitions, but what is you have to make a
 whole subtree for 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

? The second mechanism is provided by the 
\family typewriter
initialized()
\family default
 method of a node stub:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def make_tree_for_foo (ns):
\end_layout

\begin_layout Standard

  if not ns.foo.initialized():
\end_layout

\begin_layout Standard

    # define complicated subtree for foo
\end_layout

\begin_layout Standard

  return ns.foo;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first time the function is called, 
\family typewriter
initialized()
\family default
 returns 
\family typewriter
False
\family default
, so the body of the 
\family typewriter
if
\family default
 statement is executed and 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 is presumably initialized.
 For subsequent calls, 
\family typewriter
initialized()
\family default
 becomes 
\family typewriter
True
\family default
, so the body is skipped and 
\family typewriter
ns.foo
\family default
 is simply returned as is.
 If you combine it with the handy trick of assigning a node stub to a variable
 for later reuse (see below), you end up with:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def make_tree_for_foo (ns):
\end_layout

\begin_layout Standard

  foo = ns.foo;
\end_layout

\begin_layout Standard

  if not foo.initialized():
\end_layout

\begin_layout Standard

    # define complicated subtree for foo
\end_layout

\begin_layout Standard

  return foo;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which is my preferred pattern for making define-once functions.
 I prefer to 
\emph on
name
\emph default
 the top-level node stub only once, and use a local Python variable to refer
 to it everywhere else.
 With this pattern, if I later decide to rename the 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 node to 
\begin_inset Quotes eld
\end_inset

foo_with_a_twist
\begin_inset Quotes erd
\end_inset

, I only need to change the first line of the function; with the previous
 pattern, I would have to edit all the 
\family typewriter
ns.foo
\family default
 invocations.
 
\end_layout

\begin_layout Subsection
Binding via = (assignment)
\end_layout

\begin_layout Standard
It is also possible to bind a node stub to a definition by assigning to
 a node stub:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
ns.foo = Meq.Constant(value=0);
\end_layout

\begin_layout Standard
This is fully equivalent to
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
ns.foo << Meq.Constant(value=0);
\end_layout

\begin_layout Standard
The only difference is that the 
\family typewriter
<<
\family default
 operator returns the node stub itself as its result (see below), while
 assignment in Python is not an expression.
 That is, you can't say
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
a = (b=0) + 1;
\end_layout

\begin_layout Standard
in Python, as tempting as it may be to someone with a C/C++ background.
 You 
\emph on
can
\emph default
 say things like:
\end_layout

\begin_layout Standard
\InsetSpace ~

\family typewriter
\InsetSpace ~
a = b = 0;
\end_layout

\begin_layout Standard
but that's just a shorthand for two separate assignments:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
a=0; b=0;
\end_layout

\begin_layout Standard
Thus, the double assignment
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
ns.foo = ns.bar = Meq.Constant(value=0);
\end_layout

\begin_layout Standard
should initialize both 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

bar
\begin_inset Quotes erd
\end_inset

 with the same definition.
 
\end_layout

\begin_layout Standard
Personally, I don't like to use assignment with node stubs, since it can
 be easily confused with assignment to a variable.
 TDL code is clearer when you use 
\family typewriter
<<
\family default
 for all your nodes.
 Also, something like
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
a = ns.foo = Meq.Constant(value=0);
\end_layout

\begin_layout Standard
produces something entirely different (and dangerously, unintuitively so)
 from
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
a = ns.foo << Meq.Constant(value=0);
\end_layout

\begin_layout Standard
We'll take a closer look at this in section\InsetSpace ~

\begin_inset LatexCommand \ref{sec:Using-Python-variables}

\end_inset

, when we talk about the use of Python variables to refer to nodes.
\end_layout

\begin_layout Section
Hiding information
\end_layout

\begin_layout Standard
The hiding of information is one of the lesser appreciated virtues of good
 software design.
 When a framework appears to be rich in functionality and features, but
 proves to be clunky and difficult to work with in practice, it is more
 often than not due to too much information being revealed and/or shared.
\end_layout

\begin_layout Standard
An design based on many small components (functions and classes) that reveal
 and share minimal information will usually prove to be superior --- in
 the sense of being easier to use and extend --- to a functionally equivalent
 one that is based on a few aggregate components that try to do and reveal
 too much.
 One reason for this is something I call 
\emph on
assumption creep
\emph default
.
 When you write code based on an interface, you can't help making extra
 assumptions about what goes on behind the scenes, some of which invariably
 go beyond what the original developer (which may even be yourself) intended.
 The result of this can be fragile code with a spaghetti-like web of dependencie
s that is hard to extend but easy to break.
 Assumption creep can be somewhat mitigated by good coding discipline, but
 truly disciplined programmers are few and far between (I certainly don't
 count myself in that category.) A good interface that hides more than it
 reveals can be a powerful deterrent all by itself.
 This may seem counterintuitive at first (you'd think 
\begin_inset Quotes eld
\end_inset

less information
\begin_inset Quotes erd
\end_inset

 = 
\begin_inset Quotes eld
\end_inset

more assumptions
\begin_inset Quotes erd
\end_inset

), but is none the less true.
 The key word here is 
\emph on
good
\emph default
 interface.
 It's certainly possible to hide too much and/or to hide the wrong things.
 A 
\begin_inset Quotes eld
\end_inset

many small components
\begin_inset Quotes erd
\end_inset

 design may be thoroughly useless if the components hide the important things
 and reveal the trivial ones.
 
\end_layout

\begin_layout Standard
Striking the right balance between hiding and revealing information is a
 matter of judgement and hands-on experience.
 Nobody (that I know of) gets it right the first time anyway.
 My personal preference is to err on the side of caution --- expose minimal
 information at first, and reveal more in later iterations as required.
\end_layout

\begin_layout Standard
The reason I bring the subject up here is that subsequent discussion will
 feature many examples of information being hidden, in ways both good and
 bad.
 The 
\begin_inset Quotes eld
\end_inset

hiding of information
\begin_inset Quotes erd
\end_inset

 point of view can (hopefully) provide an additional perspective on what
 constitutes good and bad TDL and Python.
\end_layout

\begin_layout Section
Using Python variables and functions
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \label{sec:Using-Python-variables}

\end_inset

TDL is Python.
 Everything in Python is a first-class object.
 I don't get tired of reiterating these two basic principles because they
 are effectively the two axioms of TDL from which everything else follows.
\end_layout

\begin_layout Standard
We may have redefined the 
\family typewriter
<<
\family default
 operator in a funny way, but the things on the left- and right-hand side
 of the 
\family typewriter
<<
\family default
 are still Python objects, and they are subject to the same rules as any
 other Python objects.
 For example, we can assign them to a Python variable.
\end_layout

\begin_layout Standard
With that in mind, try to guess what this bit of code really does: 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  foo = Meq.Constant(value=1);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Does this define any nodes? Of course not.
 All it does is call 
\family typewriter
Meq.Constant()
\family default
 to create a node definition object, and associate that object with the
 Python variable 
\family typewriter
foo
\family default
.
 Because everything is a first-class object, everything and anything can
 be assigned to variables for later reuse.
 In this case, we've assigned a node definition to 
\family typewriter
foo
\family default
, so subsequently we can do:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.a << foo;
\end_layout

\begin_layout Standard

  ns.b << foo;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...to create nodes named 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, and bind the same definition to both.
 
\end_layout

\begin_layout Standard
More usefully, a node stub such as 
\family typewriter
ns.a
\family default
 is also a first-class object.
 We could have rewritten the above as:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

a = ns.a;
\end_layout

\begin_layout Standard

a << foo;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first statement here creates a node stub for 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 and assigns it to Python variable 
\family typewriter
a
\family default
, the second statement binds it with the node definition that we had previously
 assigned to 
\family typewriter
foo
\family default
.
 We've already seen things like this in a lot of the examples.
\end_layout

\begin_layout Subsection
Using functions
\end_layout

\begin_layout Standard
All Python objects can be passed in and out of functions.
 Since everything is passed by reference, you really are dealing with the
 same object both inside the function, and outside, in the calling context.
 For example:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def my_node_definition ():
\end_layout

\begin_layout Standard

  return Meq.Constant(value=1);
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

def _define_forest(ns,**kwargs):
\end_layout

\begin_layout Standard

  ns.a << my_node_definition();
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
is a perfectly legitimate way of decoupling the definition of the node,
 and hiding it away inside a function.
 I've never found this particular pattern very useful, but you may.
 
\end_layout

\begin_layout Subsubsection
Functions that define trees
\end_layout

\begin_layout Standard
A far far more important practice is illustrated by this example:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def define_tree_to_do_foo(node,a,b):
\end_layout

\begin_layout Standard

  node << a + b;
\end_layout

\begin_layout Standard

  return node;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

def _define_forest(ns,**kwargs):
\end_layout

\begin_layout Standard

  define_tree_to_do_foo(ns.a,1,2);
\end_layout

\begin_layout Standard

  define_tree_to_do_foo(ns.b,3,4);
\end_layout

\begin_layout Standard

  define_tree_to_do_foo(ns.c,ns.a,ns.b);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Think carefully about what's happening here!
\end_layout

\begin_layout Itemize
We've 
\series bold
hidden
\series default
 the knowledge of how to build a tree for this particular operation inside
 a function.
 This is a good thing --- we can change the function later without changing
 the calling code.
\end_layout

\begin_layout Itemize
We don't want the function to worry about 
\emph on
naming
\emph default
 nodes, because we're going to call it many times, to produce differently
 named nodes.
 So we name the nodes on the outside, where we create the node stub, and
 then we pass the stub as an argument to the function.
 This is a very good thing, since it 
\series bold
hides 
\series default
the business of naming from the function, and ultimately helps to avoid
 name clashes.
\begin_inset Foot
status open

\begin_layout Standard
You may wonder what happens if our function needs to name some intermediate
 nodes.
 The best way to avoid clashes then is to use subscopes, or to add qualifiers
 to the node stub that is passed in.
 This will be discussed in detail later on.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Essentially, our function has become a 
\emph on
template
\emph default
 for making a tree.
 We've already seen this at work in the ionosphere example.
 I've thrown in the 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
 parameters to show how the 
\begin_inset Quotes eld
\end_inset

template
\begin_inset Quotes erd
\end_inset

 can be made to depend on additional arguments.
 Can you guess what tree this script is going to produce? Load it up in
 the browser (
\family typewriter
?????????.py
\family default
) to see if you guessed right.
 
\end_layout

\begin_layout Standard
There's an important lesson to be learned from 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
 here.
 You don't specify parameter types when you define a Python function, and
 Python does no type checking at call time.
 So, what 
\emph on
can
\emph default
 you pass for 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
? The answer is, anything that'll work (as in, execute without an error).
 In the particular case of 
\family typewriter
define_tree_for_foo()
\family default
, this means anything that can be legally added together and bound to a
 node stub.
 So the first two times we call 
\family typewriter
define_tree_for_foo()
\family default
 with constants for 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
, and the third time with node stubs --- and each time, the function just
 works as we would intuitively expect it to.
 This is great, since it makes our function all that more flexible.
\end_layout

\begin_layout Standard
Note also the 
\begin_inset Quotes eld
\end_inset


\family typewriter
return node
\family default

\begin_inset Quotes erd
\end_inset

 statement at the end.
 The function will return the same node stub that was passed in.
 This is a convenience device.
 We ignore the return value in the example here, but in other contexts it
 may prove to be handy.
 For example, we could rewrite the three separate invocations above as one
 nested statement:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  define_tree_to_do_foo(ns.c,
\end_layout

\begin_layout Standard

    define_tree_to_do_foo(ns.a,1,2),
\end_layout

\begin_layout Standard

    define_tree_to_do_foo(ns.b,3,4)
\end_layout

\begin_layout Standard

  );
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The reverse of the medal
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \label{sub:The-reverse-of}

\end_inset

This kind of delayed type checking is a fantastically powerful feature of
 Python.
 Used properly, it allows you to write much more flexible and useful code
 than you ever could with a statically-typed language.
 Like most power tools, it will happily inflict grievous bodily harm if
 you don't show it proper respect.
 Try adding the following line to the code above:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  define_tree_to_do_foo(ns.d,ns.c,"x");
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function call executes fine, but inside the function Python throws an
 error.
 The error is obvious: you can't add a node stub to a string.
 The problem is, the 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 mistake occurs at the point where we call the function --- but Python can't
 detect it until it is executing the function itself.
 The error message is thus misleading with respect to the actual cause.
 
\end_layout

\begin_layout Standard
That's no big deal in a short script like this, but imagine we were calling
 a function in somebody else's code, and got the parameter types wrong.
 We'd see a mysterious Python error within a completely unfamiliar piece
 of code.
 Only by looking through the call stack could we get to the ultimate cause
 of the error, which is in our own code.
 Fortunately, the browser makes this easy --- every error message shows
 an associated call stack, which you can quickly click through to see where
 the error may have arisen.
\end_layout

\begin_layout Standard
This is a particular headache if you're trying to write a module or a framework
 for the benefit of the world at large.
 In my personal experience, wrong parameter types --- and the ensuing confusion
 of error messages --- have been a constant pain to beginning users of Meow.
 It is possible to partially alleviate this by adding explicit type checking
 at the entrypoints to your functions, e.g.:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def define_tree_to_do_foo(node,a,b):
\end_layout

\begin_layout Standard

  if not ( (is_node(a) or isinstance(a,(int,float,complex))) and 
\backslash

\end_layout

\begin_layout Standard

      (is_node(b) or isinstance(b,(int,float,complex))) ):
\end_layout

\begin_layout Standard

    raise TypeError,"define_tree_to_do_foo: node stubs or constants expected";
\end_layout

\begin_layout Standard

  node << a + b;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...but you can see this has the taste of a losing battle.
 Not only is it ugly and error-prone, but you can easily throw out the baby
 with the water and reduce your functions to an inflexible, inelegant mess.
 My recommendation is:
\end_layout

\begin_layout Itemize
If you're a developer, do type checking only where it's worth it.
 That is, if it's not too much of an effort, or if you think particularly
 bad confusion may ensue (this, of course, is purely a judgement call, and
 can be difficult to anticipate), then by all means do it, otherwise don't
 bother.
 
\end_layout

\begin_layout Itemize
If you're a user of somebody else's code, do not be scared of mysterious
 errors, and always check the call stack before you panic.
 More often than not, the error is yours --- and you can figure out exactly
 where it is by looking at the point where the call stack leaves your own
 code.
\end_layout

\begin_layout Subsection
Using the value of 
\family typewriter
<<
\end_layout

\begin_layout Standard
The redefined 
\family typewriter
<<
\family default
 operator, like every other Python operator (except assignment!), can have
 a return value.
 In TDL, the return value of 
\family typewriter
<<
\family default
 on a node stub is the node stub itself.
 So this bit of code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  a = ns.foo << Meq.Constant(value=1);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
does three things:
\end_layout

\begin_layout Enumerate
Creates a node stub named 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Enumerate
Binds it to a node definition returned by 
\family typewriter
Meq.Constant()
\family default
.
\end_layout

\begin_layout Enumerate
Assigns the node stub (it being the return value of 
\family typewriter
<<
\family default
) to the Python variable 
\family typewriter
a
\family default
.
\end_layout

\begin_layout Standard
Point #3 is especially convenient, as it allows us to use the variable 
\family typewriter
a
\family default
 later on when we want to refer to node 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

.
 I do this all the time, for the reason already mentioned --- if I later
 need to rename the node 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 to something else, there's only one point in the code that has to be changed.
 Think of it as another way of hiding information: you name the node 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 in only one place, where you invoke 
\family typewriter
ns.foo
\family default
.
 As far as the rest of your code is concerned, the name is hidden behind
 the 
\family typewriter
a
\family default
 variable.
\end_layout

\begin_layout Standard
In a previous section, I mentioned two similar-looking statements that do
 something completely different:
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
a = ns.foo << Meq.Constant(value=0);
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
a = ns.foo = Meq.Constant(value=0);
\end_layout

\begin_layout Standard
The first statement is 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

: it initializes the node 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 and assigns the node stub to variable 
\family typewriter
a
\family default
.
 The second statement does something way more confusing.
 Due to the way Python handles repeated assignments, it is actually equivalent
 to two separate assignments:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  a = Meq.Constant(value=0);
\end_layout

\begin_layout Standard

  ns.foo = Meq.Constant(value=0);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We've initialized node 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 fine, but the variable 
\family typewriter
a
\family default
 now refers to the node definition object, and not the node itself! I find
 this completely counterintuitive.
 
\end_layout

\begin_layout Standard
Another way to put the return value of 
\family typewriter
<<
\family default
 to good use is through nested node definitions:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.sum << Meq.Add(ns.a<<Meq.Time(),ns.b<<Meq.Freq());
\end_layout

\begin_layout Standard

  ns.other_sum = (ns.a<<1) + (ns.b<<2);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can nest these definitions to any depth, although it makes for some
 very unwieldy statements if you take it too far.
\end_layout

\begin_layout Standard
Note that all this also applies to the 
\begin_inset Quotes eld
\end_inset

optional bind
\begin_inset Quotes erd
\end_inset

 operator, 
\family typewriter
**
\family default
.
\end_layout

\begin_layout Subsection
Why you can't bind a node to a node
\end_layout

\begin_layout Standard
A common gotcha (at least in my experience of the workshops) is trying to
 bind a node stub to a node stub.
 The statement:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
ns.foo << ns.bar
\end_layout

\begin_layout Standard
is bound to produce an error --- the two things are two separate node stubs,
 so you can't just bind them together.
 The ensuing error message may be somewhat cryptic: 
\begin_inset Quotes eld
\end_inset

can't bind node name (operator <<) with argument of type _NodeStub
\begin_inset Quotes erd
\end_inset

.
 It is in fact an instance of a more broad class of error: trying to bind
 a node stub to something illegal.
 For example, the statement:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
ns.foo << 'abc';
\end_layout

\begin_layout Standard
results in a similar error: 
\begin_inset Quotes eld
\end_inset

can't bind node name (operator <<) with argument of type str
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
A more common occurence of the error is via something like:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
ns.foo << define_tree_to_do_foo (ns.a,1,2);
\end_layout

\begin_layout Standard
The function already defines and returns a node stub (
\family typewriter
ns.a
\family default
, in this case), so we can't just bind it to another node stub with 
\family typewriter
<<
\family default
.
 Usually the intent of a statement like this is to have something like an
 
\emph on
identity
\emph default
 operation, i.e., trying to make node 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 identical to node 
\begin_inset Quotes eld
\end_inset

bar
\begin_inset Quotes erd
\end_inset

.
 Of course, the nodes cannot be made truly identical --- they have different
 names, for starters.
 You can achieve identity in a mathematical sense though, by creating a
 
\family typewriter
MeqIndentity
\family default
 node:
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
ns.foo << Meq.Identity(ns.bar)
\end_layout

\begin_layout Standard
A 
\family typewriter
MeqIdentity
\family default
 simply passes along the result of its child as is.
 This trick may come in handy if you're trying to make a single node appear
 as a set of nodes (see the discussion on qualifiers below).
\end_layout

\begin_layout Subsection
Python variables: conclusion
\end_layout

\begin_layout Standard
Now, all this may seem trivial, especially if you have a good understanding
 of Python, but it is really ubiquitous throughout TDL, and so it is vitally
 important to understand thoroughly.
 To reiterate:
\end_layout

\begin_layout Itemize
Everything in Python is a first-class object
\end_layout

\begin_layout Itemize
Node stubs, node definitions (and of course the node scope itself) are Python
 objects...
\end_layout

\begin_layout Itemize
...and as such may be assigned to variables, passed into functions, and returned
 from functions.
\end_layout

\begin_layout Standard
These three points encapsulate pretty much everything you need to know about
 manipulating nodes in TDL! If you ever get confused in the future about
 what's happening in any given piece of code --- and if you use a TDL framework
 like Meow, there will be a lot of this kind of manipulation going on ---
 then you should go back and reread this section.
\end_layout

\begin_layout Section
Node definitions, up close
\end_layout

\begin_layout Standard
We have sort of glossed over the point of how a node definition comes about.
 In the example above, the invocation of 
\family typewriter
Meq.Constant(...)
\family default
 produced a node definition.
 If this looks to you like a function call, that's because it is.
 The 
\family typewriter
Meq
\family default
 object comes from the 
\family typewriter
Timba.TDL
\family default
 module, via the
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
from Timba.TDL import *
\end_layout

\begin_layout Standard
statement.
 It is also a 
\begin_inset Quotes eld
\end_inset

magic
\begin_inset Quotes erd
\end_inset

 kind of object, called a 
\emph on
class generator
\emph default
.
 Any invocation of the form
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
Meq.
\emph on
Classname
\emph default
(arg1=value1,arg2=value2...)
\end_layout

\begin_layout Standard
produces a node definition for a node of class 
\family typewriter
Meq
\emph on
Classname
\family default
\emph default
, with the given optional arguments.
 Note that the 
\family typewriter
Meq
\family default
 object is not really aware of what node classes are valid, you could write
 something like
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
Meq.BadClass(...)
\end_layout

\begin_layout Standard
and TDL will accept it; but when the tree is sent to the kernel for creation,
 it will come back with an 
\begin_inset Quotes eld
\end_inset

Unknown class 
\emph on
BadClass
\emph default

\begin_inset Quotes erd
\end_inset

 error.
 The 
\begin_inset Quotes eld
\end_inset

magic
\begin_inset Quotes erd
\end_inset

 of 
\family typewriter
Meq
\family default
 is that calling an arbitrarily-named method of the 
\family typewriter
Meq
\family default
 object results in a node definition with the class given by that name.
\end_layout

\begin_layout Standard
Likewise, the optional arguments are not enforced --- they are blindly inserted
 into the initial node state record.
 If an argument has a special meaning for a particular class of node (such
 as the 
\family typewriter
value
\family default
 argument to a 
\family typewriter
MeqConstant
\family default
), then it will have an effect on the node, and will probably be checked
 for consistency when the node is finally created inside the kernel.
 Any meaningless arguments (e.g.
 the 
\family typewriter
message
\family default
 we gave to 
\family typewriter
MeqConstant
\family default
 in our hello world script) are left to sit and rot in the state record
 exactly as they came in.
 This can actually be quite useful, as we will see later on when we look
 at node tags.
\end_layout

\begin_layout Standard
Some node classes are an exception to this rule.
 In general, if a node class has an overly complicated behaviour (in terms
 of the available arguments), then the 
\family typewriter
Meq
\family default
 object provides some explicit argument checking to make life easier.
 Some examples of this
\begin_inset Foot
status open

\begin_layout Standard
At time of writing --- it is possible that additional explicit definitions
 will be added to the 
\family typewriter
Meq
\family default
 object at a later date.
\end_layout

\end_inset

 are the 
\family typewriter
MeqParm
\family default
 and 
\family typewriter
MeqSolver
\family default
 node classes, which we'll learn about later.
 Another example is the 
\family typewriter
Meq.Matrix22()
\family default
 
\begin_inset Quotes eld
\end_inset

shortcut class
\begin_inset Quotes erd
\end_inset

 which can be used to construct a 2
\begin_inset ERT
status open

\begin_layout Standard

$
\backslash
times$
\end_layout

\end_inset

2 matrix.
 Matrices are actually created by 
\family typewriter
MeqComposer
\family default
 nodes with appropriate arguments; the 
\family typewriter
Meq.Matrix22()
\family default
 method provides a convenient shortcut.
 You can see all available shortcuts here:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
Timba/PyApps/src/TDL/MeqClasses.py
\end_layout

\begin_layout Standard
The mechanics of node definitions will become clearer as you see more examples
 and write some scripts of your own; in the meantime, all you need to remember
 is that calling any 
\family typewriter
Meq.
\emph on
Classname
\emph default
() 
\family default
usually produces a node definition of class 
\begin_inset Quotes eld
\end_inset


\emph on
Classname
\emph default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Using qualifiers
\end_layout

\begin_layout Standard
Qualifiers are one of the most powerful features of TDL.
 The example scripts we've seen before have hopefully made it clear how
 they work on an intuitive level.
 A piece of code such as
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  for k in TERMS:     
\end_layout

\begin_layout Standard

    for l in TERMS:       
\end_layout

\begin_layout Standard

      ns.f(k,l) << Meq.Polar(1,-2*math.pi*(k*x+l*y));
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
defines a series of nodes named 
\begin_inset Quotes eld
\end_inset

f:
\emph on
k
\emph default
:
\emph on
l
\emph default

\begin_inset Quotes erd
\end_inset

 in a loop, for all possible combinations of 
\begin_inset Formula $k,l$
\end_inset

.
\end_layout

\begin_layout Standard
What happens on a more technical level? A statement like
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
ns.f(k,l)
\end_layout

\begin_layout Standard
invokes the 
\emph on
function call operator
\emph default
 (
\family typewriter
__call__
\family default
) on the node stub 
\family typewriter
ns.f
\family default
.
 The function call produces a 
\emph on
new
\emph default
 node stub object, by appending the values of 
\family typewriter
k
\family default
 and 
\family typewriter
l
\family default

\begin_inset Foot
status open

\begin_layout Standard
Or more strictly, their string representation.
 Any Python object 
\family typewriter
\emph on
x
\family default
\emph default
 has a string representation, which may be obtained by calling 
\family typewriter
str(
\emph on
x
\emph default
)
\family default
.
 For non-trivial types, this may be something unexpected.
 It's a good idea to stick to numbers and strings for your qualifiers.
\end_layout

\end_inset

 to the name of the original node stub, separated by 
\begin_inset Quotes eld
\end_inset


\family typewriter
:
\family default

\begin_inset Quotes erd
\end_inset

.
 Note that the resulting node stub has absolutely no relationship to the
 original 
\family typewriter
ns.f
\family default
, apart from a meaningless (for all the node stubs know...) similarity of names.
 The following three expressions all resolve to exactly the same node stub:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.f(1,2)
\end_layout

\begin_layout Standard

  ns["f:1:2"]
\end_layout

\begin_layout Standard

  ns.f(1)(2)
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second statement illustrates that qualifiers really are just a naming
 device.
 The third statement shows that qualifiers may be chained.
 It is quite obvious if you think about it: since 
\family typewriter
ns.f(1)
\family default
 evaluates to a node stub, you can certainly repeat the qualification process
 by applying 
\begin_inset Quotes eld
\end_inset


\family typewriter
(2)
\family default

\begin_inset Quotes erd
\end_inset

 to it, and --- due to the way qualification works --- the result is the
 same as saying 
\family typewriter
ns.f(1,2)
\family default
 in the first place.
\end_layout

\begin_layout Standard
Qualifiers may also contain arbitrary keywords.
 For example, 
\family typewriter
ns.f(1,x=1,y=2)
\family default
 will result in a node stub named 
\begin_inset Quotes eld
\end_inset

f:1:x=1:y=2
\begin_inset Quotes erd
\end_inset

, as will 
\family typewriter
ns.f(1)(x=1)(y=2)
\family default
.
 I have never found keyword qualifiers to be particularly useful, but some
 people swear by them.
\end_layout

\begin_layout Subsection
Unqualified and underqualified nodes
\end_layout

\begin_layout Standard
After a loop like the one above, what does the 
\family typewriter
ns.f
\family default
 node stub refer to? The answer is, nothing in particular --- it is still
 an uninitialized node stub.
 When you build the tree, there won't be a node named 
\begin_inset Quotes eld
\end_inset

f
\begin_inset Quotes erd
\end_inset

 in it.
 You could also define it to something completely unrelated:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
ns.f << 0
\end_layout

\begin_layout Standard
would make it a 
\family typewriter
MeqConstant
\family default
 node.
 Since there's only a nominal relationship between 
\family typewriter
ns.f
\family default
 and 
\family typewriter
ns.f(
\emph on
k
\emph default
,
\emph on
l
\emph default
)
\family default
, this is a perfectly legitimate thing to do.
\end_layout

\begin_layout Standard
On the other hand, 
\family typewriter
ns.f
\family default
 can play a significant role in our code, since we know that we can qualify
 it to get at any node in the 
\begin_inset Formula $k,l$
\end_inset

 series.
 Note that the knowledge of this is vested with us --- we know that we can
 qualify 
\family typewriter
ns.f
\family default
 with two numbers to get at one of the nodes in a series, because that's
 the way our script was written.
 The 
\family typewriter
ns.f
\family default
 node itself has no knowledge of this.
 We could say something like
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
foobar = ns.f('foo','bar')
\end_layout

\begin_layout Standard
and get back a node stub named 
\begin_inset Quotes eld
\end_inset

f:foo:bar
\begin_inset Quotes erd
\end_inset

, with no-one the wiser.
 The 
\family typewriter
ns.f
\family default
 node stub doesn't know (nor should it) whether 
\begin_inset Quotes eld
\end_inset

f:foo:bar
\begin_inset Quotes erd
\end_inset

 refers to a valid & initialized node or not.
 An error can only arise later, if we happen to use 
\family typewriter
foobar
\family default
 in a context where a valid node is expected.
 For example,
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
ns.sum << foobar + ns.f(1,2)
\end_layout

\begin_layout Standard
will produce an error in the 
\begin_inset Quotes eld
\end_inset

sum
\begin_inset Quotes erd
\end_inset

 node, complaining that the first child has not been initialized.
\end_layout

\begin_layout Standard
Still, the 
\family typewriter
ns.f
\family default
 node stub is an extremely useful object, because we can use it to refer
 to all the 
\begin_inset Quotes eld
\end_inset

f:
\emph on
k
\emph default
:
\emph on
l
\emph default

\begin_inset Quotes erd
\end_inset

 nodes in bulk, as long as we remember to qualify it properly.
 When used like this, 
\family typewriter
ns.f
\family default
 is called an 
\emph on
unqualified node.

\emph default
 This can be a very powerful technique, as illustrated by 
\family typewriter
Intro1/demo4-more_quals.py
\family default
:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def sum_series (sumnode,fnodes):
\end_layout

\begin_layout Standard

  sumnode << Meq.Add(*[fnodes(k,l) for k in TERMS for l in TERMS]);
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

def sum_sq_series (sumnode,fnodes):
\end_layout

\begin_layout Standard

  sumnode << Meq.Add(*[Meq.Sqr(fnodes(k,l)) for k in TERMS for l in TERMS]);
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

def _define_forest (ns, **kwargs):
\end_layout

\begin_layout Standard

  # (some code skipped)
\end_layout

\begin_layout Standard

  for k in TERMS:
\end_layout

\begin_layout Standard

    for l in TERMS:
\end_layout

\begin_layout Standard

      ns.f(k,l) << Meq.Polar(1,-2*math.pi*(k*x+l*y));
\end_layout

\begin_layout Standard

  sum_series(ns.sum,ns.f);
\end_layout

\begin_layout Standard

  sum_sq_series(ns.sum_sq,ns.f);
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
sum_series()
\family default
 function implements summation over a 
\begin_inset Formula $k,l$
\end_inset

 series.
 It has no knowledge of the series itself --- all it knows is that it gets
 an 
\family typewriter
fnodes
\family default
 object that it can qualify with a 
\begin_inset Formula $k,l$
\end_inset

 pair (with 
\begin_inset Formula $k,l$
\end_inset

 within some known limits) to get at the individual terms of the series.
 This is a good way of hiding information.
 In the context, we say that 
\family typewriter
sum_series()
\family default
 expects an 
\emph on
unqualified node
\emph default
 for its 
\family typewriter
fnodes
\family default
 parameter.
\begin_inset Foot
status open

\begin_layout Standard
If the syntax
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
*[fnodes(k,l) for k in TERMS for l in TERMS]
\end_layout

\begin_layout Standard
looks unfamiliar, then you're really missing out on some great labour-saving
 Python tricks.
 In brief, the 
\begin_inset Quotes eld
\end_inset


\family typewriter
[
\family default
\emph on
expr
\emph default
 
\family typewriter
for 
\family default
\emph on
x
\emph default
 
\family typewriter
in
\family default
 
\emph on
L
\emph default
 
\family typewriter
\emph on
[
\emph default
for 
\family default
\emph on
y
\emph default
 
\family typewriter
in 
\family default
\emph on
M
\emph default
 ...
\emph on
]
\emph default
 
\family typewriter
]
\family default

\begin_inset Quotes erd
\end_inset

 syntax is called 
\emph on
list comprehension
\emph default
.
 It evaluates 
\emph on
expr
\emph default
 in a loop over all values of
\emph on
 L 
\emph default
(and 
\emph on
M
\emph default
, if a second 
\family typewriter
for
\family default
 clause is specified, etc.), while replacing all occurences of 
\emph on
x
\emph default
 (and 
\emph on
y
\emph default
, etc.) in 
\emph on
expr
\emph default
 by the corresponding list elements.
 The result of this is a list composed of the values of 
\emph on
expr
\emph default
.
 
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\family typewriter
*
\family default

\begin_inset Quotes erd
\end_inset

 before the list is a completely independent operation.
 This causes the function to be invoked with parameters composed from the
 given list.
 For example,
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
L = [1,2,3];
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
M = [10,20,30];
\end_layout

\begin_layout Standard

\family typewriter
\InsetSpace ~
\InsetSpace ~
foo(*[x+y for x in L for y in M])
\end_layout

\begin_layout Standard
will call the function 
\family typewriter
foo
\family default
 as 
\family typewriter
foo(11,12,13,21,22,23,31,32,33)
\family default
.
\end_layout

\begin_layout Standard
List comprehension (and the 
\family typewriter

\begin_inset Quotes eld
\end_inset

*
\family default

\begin_inset Quotes erd
\end_inset

 parameter list syntax) is a very important technique to understand thoroughly,
 since it is ubiquitous throughout our TDL scripts.
 It really 
\emph on
does
\emph default
 make life easier!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On a similar note, what does 
\family typewriter
ns.f(1)
\family default
 refer to? On the one hand, it's just a node stub named 
\begin_inset Quotes eld
\end_inset

f:1
\begin_inset Quotes erd
\end_inset

, which is not initialized to a valid node anywhere in our code.
 On the other hand, it's a means to refer to all the nodes named 
\begin_inset Quotes eld
\end_inset

f:1:
\emph on
l
\emph default

\begin_inset Quotes erd
\end_inset

, as a series.
 In this latter context we call it an 
\emph on
underqualified
\emph default
 node, because we can append an extra qualifier to make it refer to a 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 (i.e.
 valid & initialized) node.
 We could write a function to sum over a one-dimensional series:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def sum_1d_series (sumnode,fnodes):
\end_layout

\begin_layout Standard

  sumnode << Meq.Add(*[fnodes(k) for k in TERMS]);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and then invoke it to make sums over slices over 
\begin_inset Formula $l$
\end_inset

 through 
\begin_inset Quotes eld
\end_inset

f:
\emph on
k
\emph default
:
\emph on
l
\emph default

\begin_inset Quotes erd
\end_inset

, for a given 
\begin_inset Formula $k$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  sum_1d_series(ns.sum1,ns.f(1));
\end_layout

\begin_layout Standard

  sum_1d_series(ns.sum2,ns.f(2));
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Design by contract
\end_layout

\begin_layout Standard
You'd be right to wonder if we could somehow use the same function to sum
 over slices in the other direction, i.e.
 over 
\begin_inset Formula $k$
\end_inset

 for a given 
\emph on
l
\emph default
.
 The qualifier syntax only allows us to append qualifiers; there's no easy
 prepend feature.
 Python's absense of type checking comes to the rescue here.
 If you look at the code for 
\family typewriter
sum_1d_series()
\family default
, you can see that there's nothing in it that actually requires the 
\family typewriter
fnodes
\family default
 argument to be a node stub.
 All the function really requires is that 
\family typewriter
fnodes
\family default
 be something that can be qualified with a single index (
\begin_inset Formula $k$
\end_inset

) to yield a valid node stub.
 If we had a function that took a single argument --- the missing 
\begin_inset Formula $k$
\end_inset

 qualifier --- and returned a fully-qualified node stub, we could pass that
 function as the 
\family typewriter
fnodes
\family default
 parameter, and 
\family typewriter
sum_1d_series()
\family default
 would do exactly the right thing.
 Python's 
\emph on
lambda
\emph default
 syntax makes it easy to construct such a function on-the-fly:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  sum_1d_series(ns.sum1,lambda k:ns.f(k,1));
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This defines an anonymous function
\begin_inset Foot
status open

\begin_layout Standard
The term 
\emph on
lambda
\emph default
 comes from functional programming, which ultimately got it from the 
\begin_inset Formula $\lambda$
\end_inset

 operation in functional calculus.
\end_layout

\end_inset

 , with one argument, 
\family typewriter
k
\family default
, returning 
\family typewriter
ns.f(k,1)
\family default
.
 Inside 
\family typewriter
sum_1d_series()
\family default
, this lambda-function then behaves in exactly the same way that an underqualifi
ed node stub would have.
\end_layout

\begin_layout Standard
This technique is an illustration of something called 
\emph on
design by contract
\emph default
.
 Instead of specifying that our 
\family typewriter
sum_1d_series()
\family default
 function takes an argument of type node stub (
\begin_inset Quotes eld
\end_inset

design by type
\begin_inset Quotes erd
\end_inset

), we only specify that the parameter should implement some kind of behaviour
 --- that it behaves 
\begin_inset Quotes eld
\end_inset

like
\begin_inset Quotes erd
\end_inset

 a node stub w.r.t.
 qualification.
 This behaviour requirement is called a 
\emph on
contract
\emph default
.
 In this particular case, the contract on 
\family typewriter
fnodes
\family default
 is that it supports the function call operator, and that 
\family typewriter
fnodes(k)
\family default
 returns a valid node stub.
\end_layout

\begin_layout Standard
Design by contract is made possible by Python's late type-checking mechanism.
 It is a very powerful technique: by not tying our interfaces to specific
 types, it allows us to keep them all that more flexible.
 On the other hand, it carries with it all the risks discussed in section\InsetSpace ~

\begin_inset LatexCommand \ref{sub:The-reverse-of}

\end_inset

.
 These can be mitigated by making sure that your interfaces are built around
 a limited set of fairly simple and well-defined contracts.
 The contract on 
\family typewriter
fnodes
\family default
, above, is a good example, and is used extensively in frameworks like Meow
 (which we will look at in a subsequent chapter).
\end_layout

\begin_layout Section
Built-in node arithmetic
\end_layout

\begin_layout Section
Node tags and scope searches
\end_layout

\begin_layout Chapter
What's In a Name?
\end_layout

\begin_layout Standard
Naming can be a difficult business --- just ask Ford Prefect (???).
 For various good reasons that we will not go into too deeply, every node
 in the tree must have a unique name.
 It would be easy to generate unique names automatically, but these would
 be largely meaningless to the user.
 Good, meaningful node names are important, because they make a tree easier
 to understand.
 This in turn makes it easier to indentify intermediate values, keep track
 of what's going on, and locate potential errors.
\end_layout

\begin_layout Standard
Real-life trees can have thousands of nodes, and it would be rather tedious
 if we had to choose names for them all.
 TDL provides a number of convenient shortcuts.
 First of all, repeated structures in the tree (such as per-baseline, per-source
 and per-station branches) can be given different qualifiers.
 Then there's implicit arithmetic and automatic node naming, which assigns
 names to intermediate nodes for us.
 Recall our first 
\begin_inset Quotes eld
\end_inset

meaningful
\begin_inset Quotes erd
\end_inset

 tree of section\InsetSpace ~

\begin_inset LatexCommand \ref{sec:Our-first-"real"}

\end_inset

, which implemented the expression:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
f=\alpha\sin(bx+cy+1).\]

\end_inset


\end_layout

\begin_layout Standard
In TDL, such a subtree can be defined by a single statement:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.f << ns.alpha*Meq.Sin(ns.b*ns.x + ns.c*ns.y + 1)
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...provided we have already defined the 
\family typewriter
alpha
\family default
, 
\family typewriter
b
\family default
, 
\family typewriter
c
\family default
, 
\family typewriter
x
\family default
 and 
\family typewriter
y
\family default
 nodes.
 All the intermediates nodes in this expression will be assigned names automatic
ally, based on their class and arguments.
 If you study these names in the browser, you'll see a clear meaning to
 them.
\end_layout

\begin_layout Standard
Is it a good idea to rely on these automatic names? In general, they tend
 to make life a lot easier, but, like any good idea, they can be taken too
 far.
 For example, the following is perfectly legitimate TDL:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns.f << 297*Meq.Sin(1*Meq.Freq() + 2*Meq.Time() + 1)
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...but the resulting tree will be much more difficult to understand.
\end_layout

\begin_layout Standard
In general, I would recommend the following guidelines:
\end_layout

\begin_layout Itemize
If a node represents some well-defined physical or mathematical quantity,
 name it explicitly.
\end_layout

\begin_layout Itemize
If a node represents something you might want to look at separately, name
 it explicitly.
\end_layout

\begin_layout Itemize
Otherwise, allow automatic naming to take care of it.
\end_layout

\begin_layout Standard
Striking the right balance here is a matter of feeling and personal preference.
 Trees that explicitly name every single node are easy to understand, but
 take a lot more TDL code (which in itself can be difficult to read).
 Trees that explicitly name barely anything at all may be easy to code,
 but will be perfectly inscrutable.
\end_layout

\begin_layout Standard
Of course, picking the right name is only part of the problem.
 Imagine you're using a framework or a module that was written by Bob.
 This module will build a large part of the tree for you, using some naming
 scheme invented by Bob.
 The details of this scheme are hidden inside Bob's code, so you could very
 well end up using the same names for your own, compelely unrelated nodes.
 All sorts of confusion may ensue, all the worse if Bob (and/or you) is
 sloppy in his naming, or if he's fond of generic names like 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

y
\begin_inset Quotes erd
\end_inset

.
 Then you try to make use of another module, this one written by Alice,
 with its own naming scheme.
 There's now three potential sources of conflicting names.
 Then you pull out all your hair and swear off other people's code for life...
\end_layout

\begin_layout Standard
This scenario shows that using good naming schemes, and avoiding naming
 conflicts, is terribly important --- the more so as your scripts get more
 complex and as you start sharing code with other people.
 This is a matter of good coding practice.
 Fortunately, TDL provides a number of tools that, if properly used, let
 you implement good naming practices will relatively little effort.
 The purpose of this chapter is to discuss these tools and practices in
 depth.
\end_layout

\begin_layout Section
Node scopes
\end_layout

\begin_layout Standard
Up till now, we've only dealt with the 
\emph on
global node scope
\emph default
, a.k.a.
 the 
\family typewriter
ns
\family default
 object.
 The good news (for people wanting to avoid name conflicts) is that we can
 make use of other node scopes.
 If you're familiar with C++ namespaces, or just name scopes in general,
 then this concept should be quite familiar.
 For example, in the following bit of (rather silly) Python code, the name
 
\family typewriter
foo
\family default
 appears twice:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def a():
\end_layout

\begin_layout Standard

  foo = 1;
\end_layout

\begin_layout Standard

  return foo;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

def b():
\end_layout

\begin_layout Standard

  foo = 2;
\end_layout

\begin_layout Standard

  return foo;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...yet there's no confusion at all between the two 
\family typewriter
foo
\family default
's, because one resides in the local scope of function 
\family typewriter
a()
\family default
, and the other in the local scope of 
\family typewriter
b()
\family default
.
 In C++, you could have something like:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

namespace a
\end_layout

\begin_layout Standard

{
\end_layout

\begin_layout Standard

  int foo;
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard

int foo;
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

int b ()
\end_layout

\begin_layout Standard

{
\end_layout

\begin_layout Standard

  int foo = 2;
\end_layout

\begin_layout Standard

  return foo + ::foo + a::foo;
\end_layout

\begin_layout Standard

}
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Again, we have three separate 
\family typewriter
foo
\family default
s.
 One is declared in 
\emph on
namespace
\emph default
 a, another in the global scope, and the third in the local scope of function
 
\family typewriter
b()
\family default
.
 It is even possible to explicitly refer to the 
\begin_inset Quotes eld
\end_inset

other
\begin_inset Quotes erd
\end_inset

 
\family typewriter
foo
\family default
s inside of 
\family typewriter
b()
\family default
, by prepending 
\begin_inset Quotes eld
\end_inset


\family typewriter
::
\family default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\family typewriter
a::
\family default

\begin_inset Quotes erd
\end_inset

 to the name.
\end_layout

\begin_layout Standard
TDL provides a similar (though more powerful) mechanism via node scopes.
 Think of a node scope object as a naming device.
 The global node scope is the equivalent of global name scope of most programmin
g langauges.
 If 
\family typewriter
ns
\family default
 is the global node scope, then 
\family typewriter
ns.foo
\family default
 refers to the name 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

.
 The name 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 is global in the sense that anyone else attempting to define a node named
 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 will end up referring to the same name.
\end_layout

\begin_layout Subsection
Subscopes
\end_layout

\begin_layout Standard
If we want make different distinct 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 nodes, we can make use of subscopes.
 This bit of TDL code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  nsa = ns.Subscope("a");
\end_layout

\begin_layout Standard

  nsb = ns.Subscope("b");
\end_layout

\begin_layout Standard

  ns.foo << 1;
\end_layout

\begin_layout Standard

  nsa.foo << 2;
\end_layout

\begin_layout Standard

  nsb.foo << 3;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will define three nodes named 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

a::foo
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

b::foo
\begin_inset Quotes erd
\end_inset

.
 The 
\family typewriter
nsa
\family default
 and 
\family typewriter
nsb
\family default
 objects are called 
\emph on
subscopes
\emph default
.
 When you declare node stubs inside a subscope, the name of the subscope
 is prepended to the node name, separated by 
\begin_inset Quotes eld
\end_inset

::
\begin_inset Quotes erd
\end_inset

.
 Note that this is purely a naming trick.
 You could declare something like
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  ns1 = ns.Subscope("a");
\end_layout

\begin_layout Standard

  ns2 = ns.Subscope("a");
\end_layout

\begin_layout Standard

  ns1.foo << 1;
\end_layout

\begin_layout Standard

  ns2.foo << 2;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and get back a 
\begin_inset Quotes eld
\end_inset

node redefined
\begin_inset Quotes erd
\end_inset

 error, because while the 
\family typewriter
ns1
\family default
 and 
\family typewriter
ns2
\family default
 subscopes are, technically, different Python objects, they name their nodes
 the same way.
 Likewise, if 
\family typewriter
ns
\family default
 is the global node scope, then 
\family typewriter
ns['a::foo']
\family default
 is yet another way to refer to 
\begin_inset Quotes eld
\end_inset

a::foo
\begin_inset Quotes erd
\end_inset

.
 The bottom line is that all node names still reside within a single global
 
\emph on
name
\emph default
 scope --- subscopes are simply a handy way to automatically prepend something
 to a name.
 This is similar to what happens with qualifiers.
 For example, if 
\family typewriter
nsa
\family default
 is a subscope of 
\family typewriter
ns
\family default
 named 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, then 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  nsa.foo(1)
\end_layout

\begin_layout Standard

  ns['a::foo'](1)
\end_layout

\begin_layout Standard

  ns['a::foo:1']
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
are simply three different ways of referring to the same name, 
\begin_inset Quotes eld
\end_inset

a::foo:1
\begin_inset Quotes erd
\end_inset

.
 Subscopes and qualifiers are merely naming devices, so it is important
 that you understand exactly what they do and don't do!
\end_layout

\begin_layout Subsection
A subscope is just a scope
\end_layout

\begin_layout Standard
The power of subscopes lies in the fact that they're entirely indistiguishable,
 from a program's point of view, from the global node scope.
 All node scopes are instances of the 
\family typewriter
TDL.NodeScope
\family default
 class.
 When you pass a node scope to a function, the function has no way of knowing
 whether it's dealing with the global scope or a subscope, because the object
 
\begin_inset Quotes eld
\end_inset

looks and feels
\begin_inset Quotes erd
\end_inset

 the same way.
 This is another instance of 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

 information hiding.
 
\end_layout

\begin_layout Standard
Consider our Alice/Bob scenario.
 Say we're trying to make use of Alice's module, 
\family typewriter
alice.py
\family default
, which contains
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def make_useful_subtree (ns,node,a=1):
\end_layout

\begin_layout Standard

  ns.foo << a + 1;
\end_layout

\begin_layout Standard

  node << ns.foo + Meq.Freq();
\end_layout

\begin_layout Standard

  return node;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Obviously, Alice is aware of the good practice of letting the caller create
 and pass in the 
\begin_inset Quotes eld
\end_inset

output
\begin_inset Quotes erd
\end_inset

 node stub as the 
\family typewriter
node
\family default
 argument.
 Then, we're also trying to pull in 
\family typewriter
bob.py
\family default
:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def make_really_useful_subtree (ns,b=1):
\end_layout

\begin_layout Standard

  ns.foo << b*2;
\end_layout

\begin_layout Standard

  ns.bar << ns.foo + Meq.Time();
\end_layout

\begin_layout Standard

  return ns.bar;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bob's module prefers to declare its own output node stub.
 When we try to combine the two in our own code, we start out with something
 like:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  import alice;
\end_layout

\begin_layout Standard

  import bob;
\end_layout

\begin_layout Standard

  x = alice.make_useful_subtree(ns,ns.x,a=1);
\end_layout

\begin_layout Standard

  y = bob.make_useful_subtree(ns,b=2);
\end_layout

\begin_layout Standard

  ns.bar << ns.x + ns.y;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This produces at least two naming conflicts --- both Alice and Bob use 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

, and both Bob and us use 
\begin_inset Quotes eld
\end_inset

bar
\begin_inset Quotes erd
\end_inset

.
 The easiest way to resolve this problem is to put Alice and Bob into separate
 subscopes:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  x = alice.make_useful_subtree(ns.Subscope("alice"),ns.x,a=1);
\end_layout

\begin_layout Standard

  y = bob.make_useful_subtree(ns.Subscope("bob"),b=2);
\end_layout

\begin_layout Standard

  ns.bar << ns.x + ns.y;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All Alice's nodes will now be called 
\begin_inset Quotes eld
\end_inset

alice::...
\begin_inset Quotes erd
\end_inset

, all Bob's nodes will be called 
\begin_inset Quotes eld
\end_inset

bob::...
\begin_inset Quotes erd
\end_inset

, and we can freely use the global scope for our own nodes without worrying
 about naming conflicts.
 
\end_layout

\begin_layout Standard
This is great, because it allows us to treat Alice and Bob's modules as
 a black box (which we should be entitled to), and not worry about how they
 name their nodes internally.
 
\end_layout

\begin_layout Subsection
Qualifying subscopes
\end_layout

\begin_layout Standard
When creating a subscope, you can also pass in arbitrary qualifiers:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  nsa = ns.Subscope("a",1,x=2);
\end_layout

\begin_layout Standard

  nsa.foo << 1;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...creates a subscope named 
\begin_inset Quotes eld
\end_inset

a:1:x=2
\begin_inset Quotes erd
\end_inset

, and a node named 
\begin_inset Quotes eld
\end_inset

a:1:x=2::foo
\begin_inset Quotes erd
\end_inset

.
 Again, this is only a naming convenience --- we could have achieved exactly
 the same result by saying:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  nsa = ns.Subscope("a:1:x=2");
\end_layout

\begin_layout Standard

  nsa.foo << 1;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
QualScopes
\end_layout

\begin_layout Standard
A 
\emph on
QualScope
\emph default
 is a variation on the subscope theme.
 You can create a qualscope with an arbitrary set of qualifiers:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  nsq = ns.QualScope("x",y=1);
\end_layout

\begin_layout Standard

  nsq.foo << 1;
\end_layout

\begin_layout Standard

  nsq.bar(2,a=3);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...and the qualscope's qualifiers will be 
\emph on
prepended
\emph default
 to the set of a node's qualifiers when creating nodes within that qualscope.
 Thus, the example above produces nodes named 
\begin_inset Quotes eld
\end_inset

foo:x:y=1
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

bar:x:y=1:2:a=3
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Qualscopes are very useful when you know you will be creating a large number
 of nodes sharing the same qualifiers.
 For example, classes in the the 
\family typewriter
Meow.SkyComponent
\family default
 hierarchy, which represent individual sources on the sky, make themselves
 a qualscope using the source name as a qualifier.
 All nodes related to that component are then created within that qualscope,
 and thus are automatically qualified with the source name.
\end_layout

\begin_layout Subsection
Nesting scopes
\end_layout

\begin_layout Standard
Just like subscopes, qualscopes are also fully-fleged scopes.
 This means you can do anything with a qualscope that you could with the
 global node scope, including creating another qualscope or subscope within
 it.
 This leads to 
\emph on
nested
\emph default
 scopes:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  nsa = ns.Subscope("a");
\end_layout

\begin_layout Standard

  nsq = ns.QualScope("x",y=1);
\end_layout

\begin_layout Standard

  nsq1 = nsa.QualScope("z",t=2);   # nested qualscope
\end_layout

\begin_layout Standard

  nsb = nsq1.Subscope("b");        # nested subscope
\end_layout

\begin_layout Standard

  nsq2 = nsb.QualScope("x",y=2);
\end_layout

\begin_layout Standard

  nsa.foo << 1;                    # creates "a::foo"
\end_layout

\begin_layout Standard

  nsq.foo << 1;                    # creates "foo:x:y=1"
\end_layout

\begin_layout Standard

  nsq1.foo << 1;                   # creates "a::foo:z:t=2"
\end_layout

\begin_layout Standard

  nsb.foo << 1;                    # creates "a::b::foo:z:t=2"
\end_layout

\begin_layout Standard

  nsq2.foo << 1;                   # creates "a::b::foo:z:t=2:x:y=2"
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Having too many nested scopes can look confusing, but you don't generally
 need to worry about it.
 The important thing to know is that you can always make a subscope or qualscope
 from any scope.
 Returning to our Alice/Bob example, if Alice's function were to look like
 this:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def make_useful_subtree (ns,node,a=1):
\end_layout

\begin_layout Standard

  qualscope = ns.QualScope(alice=a);
\end_layout

\begin_layout Standard

  qualscope.foo << a + 1;
\end_layout

\begin_layout Standard

  node << ns.foo + Meq.Freq();
\end_layout

\begin_layout Standard

  return node;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...it would work perfectly fine whethere invoked as 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  alice.make_useful_subtree (ns,ns.x,a=1);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...or as
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  alice.make_useful_subtree (ns.Subscope("alice"),ns.x,a=1);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the first case the foo node will be named 
\begin_inset Quotes eld
\end_inset

foo:alice=1
\begin_inset Quotes erd
\end_inset

, in the second case 
\begin_inset Quotes eld
\end_inset

alice::foo:alice=1
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The bottom line is, if you're Alice or Bob --- writing modules for other
 people to use --- you're free to make sensible use of subscopes and qualscopes
 within your own module, as long as these are derived from the 
\family typewriter
ns
\family default
 object that the user of your code passes in.
 The 
\begin_inset Quotes eld
\end_inset

user
\begin_inset Quotes erd
\end_inset

 can then decide to 
\begin_inset Quotes eld
\end_inset

sandbox
\begin_inset Quotes erd
\end_inset

 you module into a subscope as he or she sees fit; your own subscopes and
 qualscopes will then nest inside the subscope that the user has selected
 for you, but it's not something you need to concern yourself with at all.
\end_layout

\begin_layout Subsection
Scopifying nodes
\end_layout

\begin_layout Chapter
Meow: a Case Study
\end_layout

\begin_layout Standard
Meow (Measurement Equation Object frameWork) makes extensive use of all
 the Python and TDL techniques discussed in the previous chapter.
 In this chapter, we're going to take an in-depth look at some example scripts
 that employ Meow, to see how these methods can fit together into a coherent
 whole.
\end_layout

\begin_layout Section
Jones series
\end_layout

\begin_layout Standard
A Jones term is a 
\begin_inset Formula $2\times2$
\end_inset

 matrix
\begin_inset Foot
status open

\begin_layout Standard
A Jones matrix can also be represented by a single scalar 
\begin_inset Formula $g$
\end_inset

, which is mathematically equivalent to the diagonal matrix 
\begin_inset Formula $G=\left(\begin{array}{cc}
g & 0\\
0 & g\end{array}\right).$
\end_inset

 Matrix operations in MeqTrees work the same whether the 
\begin_inset Formula $g$
\end_inset

 or 
\begin_inset Formula $G$
\end_inset

 form is used, so we will not dwell any further on the distinction.
\end_layout

\end_inset

 that describes a signal propagation effect.
 The word 
\emph on
term
\emph default
 is used because a Jones matrix usually appears as a term of a 
\emph on
measurement equation
\emph default
.
 When putting together a measurement equation, we usually have a separate
 Jones term per antenna, or, if the effect also happens to be direction-dependen
t, a separate term per antenna and per direction on the sky (which usually
 corresponds to what we call a 
\begin_inset Quotes eld
\end_inset

source
\begin_inset Quotes erd
\end_inset

, since we model the sky by a collection of discrete sources.) A set of Jones
 terms describing the same effect per antenna and/or per source is called
 a 
\emph on
Jones series
\emph default
.
\end_layout

\begin_layout Standard
The TDL qualifier mechanism is a godsend when creating and manupulating
 Jones series.
 As a working example, let's look at the 
\family typewriter
ME2/example6-iono.py
\family default
 script.
 The measurement equation used here needs a series of Jones terms (the 
\begin_inset Quotes eld
\end_inset

zeta-Jones
\begin_inset Quotes erd
\end_inset

, from the ionospheric phase delay 
\begin_inset Formula $\zeta$
\end_inset

), 
\begin_inset Formula $Z_{kp}$
\end_inset

, one per each source 
\begin_inset Formula $k$
\end_inset

 and antenna 
\begin_inset Formula $p$
\end_inset

.
 The trees for these are created by the following call:
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
Zj = iono_model.compute_zeta_jones(ns,sources);
\family default
 
\end_layout

\begin_layout Standard
The 
\family typewriter
compute_zeta_jones()
\family default
 takes a node scope and a list of Meow source objects, and creates a series
 of 
\begin_inset Formula $Z$
\end_inset

 nodes.
 These will be created as
\end_layout

\begin_layout Standard
\InsetSpace ~
\InsetSpace ~

\family typewriter
ns.Z(source_name,p)
\end_layout

\begin_layout Standard
where 
\family typewriter
source_name
\family default
 is obtained from each source object, and 
\family typewriter
p
\family default
 is an antenna index.
 Ultimately, the nodes are created inside this function from 
\family typewriter
ME2/iono_geometry.py
\family default
:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def compute_zeta_jones_from_tecs (ns,tecs,source_list):
\end_layout

\begin_layout Standard

  """Creates the Z Jones for ionospheric phase,
\end_layout

\begin_layout Standard

  given TECs (per source,   per station).""";
\end_layout

\begin_layout Standard

  zeta = ns.Z;   
\end_layout

\begin_layout Standard

  for src in source_list:
\end_layout

\begin_layout Standard

    for p in Context.array.stations():
\end_layout

\begin_layout Standard

      zeta(src.name,p) << Meq.Polar(1,-25*Lightspeed*tecs(src.name,p)/Meq.Freq());
\end_layout

\begin_layout Standard

  return zeta;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you've followed this chapter until now, it should be pretty clear what's
 going on here.
 First we make a node stub, 
\family typewriter
ns.Z
\family default
, and assign it to the variable 
\family typewriter
zeta
\family default
.
 Then we loop over sources and stations, and define a 
\family typewriter
zeta(src.name,p)
\family default
 node for each.
 Since 
\family typewriter
zeta
\family default
 is just a reference to 
\family typewriter
ns.Z
\family default
, this is the same as simply creating 
\family typewriter
ns.Z(src.name,p)
\family default
.
 Finally, we return the 
\family typewriter
ns.Z
\family default
 node stub.
\end_layout

\begin_layout Standard
The caller of this function doesn't know how the 
\begin_inset Formula $Z$
\end_inset

-Jones nodes are named or how they are created.
 All the caller needs to know is the contract on the return value: 
\begin_inset Quotes eld
\end_inset

something that can be qualified with a source name 
\begin_inset Formula $k$
\end_inset

 and an antenna index 
\begin_inset Formula $p$
\end_inset

 to obtain the node stub for 
\begin_inset Formula $Z_{kp}$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Now, how do we use the 
\begin_inset Formula $Z$
\end_inset

 terms? Looking at 
\family typewriter
ME2/example6-iono.py
\family default
:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  for src in sources:
\end_layout

\begin_layout Standard

    allsky.add(src.corrupt(Zj(src.name))); 
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To create a 
\begin_inset Quotes eld
\end_inset

corrupted
\begin_inset Quotes erd
\end_inset

 source, we need to apply the Jones terms to a source.
 We know that a Meow source object implements a 
\family typewriter
corrupt(J)
\family default
 method that takes a Jones series as a parameter.
 The contract on the 
\family typewriter
J
\family default
 parameter is 
\begin_inset Quotes eld
\end_inset

something that can be qualified with an antenna index 
\begin_inset Formula $p$
\end_inset

 to obtain a node stub for the Jones term corresponding to antenna 
\begin_inset Formula $p$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\begin_inset Foot
status open

\begin_layout Standard
Unless corrupt is called as 
\family typewriter
corrupt(J,per_station=False)
\family default
, in which case it knows that 
\family typewriter
J
\family default
 is not a per-antenna series, but a single Jones term.
\end_layout

\end_inset

 Well, this is almost a perfect fit with the previous contract --- we know
 that 
\family typewriter
Zj
\family default
 takes two qualifiers, so 
\family typewriter
Zj(src.name)
\family default
 produces an underqualified node stub that is exactly the thing we want
 to pass to 
\family typewriter
corrupt()
\family default
.
 Inside 
\family typewriter
corrupt()
\family default
 there will be a loop over stations, which will end up accessing the individual
 Jones terms as 
\family typewriter
J(p)
\family default
, which is the same thing as 
\family typewriter
Zj(src.name)(p)
\family default
, which is the same thing as 
\family typewriter
Zj(src.name,p)
\family default
, which is simply 
\family typewriter
ns.Z(src.name,p)
\family default
.
\begin_inset Foot
status open

\begin_layout Standard
The sharp-eyed reader will notice that sometimes the example scripts use
 
\family typewriter
src.direction.name
\family default
 rather than 
\family typewriter
src.name
\family default
.
 For most intents and purposes, this is the same thing.
 Every source has a 
\family typewriter
direction
\family default
 attribute that has a 
\family typewriter
name
\family default
, which is almost always identical to the source name, since most scripts
 have a one-to-one correspondence between sources and directions.
 In more exotic scenarios we can have multiple sources in the same direction,
 in which case you really want to have a per-direction rather than a per-source
 Jones term.
 Even though none of the examples actually realize this scenario, the 
\family typewriter
src.direction.name
\family default
 thing has crept in.
 I apologize for any confusion.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Mea culpa
\end_layout

\begin_layout Standard
The 
\family typewriter
compute_zeta_jones()
\family default
 function as shown here (and in the demo scripts) has one somewhat glaring
 design defect.
 We name the 
\family typewriter
ns.Z
\family default
 node inside the function.
 What if we also use a different piece of code that wants to make a 
\begin_inset Quotes eld
\end_inset

Z
\begin_inset Quotes erd
\end_inset

 node? All sorts of confusion ensues.
 
\end_layout

\begin_layout Standard
The more robust appproach to node naming is illustrated by the function
 in section\InsetSpace ~

\begin_inset LatexCommand \ref{sec:Using-Python-variables}

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def define_tree_to_do_foo(node,a,b):
\end_layout

\begin_layout Standard

  node << a + b;
\end_layout

\begin_layout Standard

  return node;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, we name the node outside the function, and pass in a node stub.
 This a much better approach than allowing functions to pick their own names,
 since it gives the caller an opportunity to avoid name clashes.
 We want to 
\series bold
hide
\series default
 the business of node naming from functions as much as possible.
\end_layout

\begin_layout Standard
In these particular circumstances this is only a minor sin --- the letter
 
\begin_inset Formula $Z$
\end_inset

 is (hopefully) a well-established term for ionopsheric phase, so it's unlikely
 that someone else will have another 
\begin_inset Formula $Z$
\end_inset

 of their own.
 Even then, this sort of thing is to be avoided in a proper design!
\end_layout

\begin_layout Section
Using contract adapters
\end_layout

\begin_layout Standard
The 
\family typewriter
Zj(src.name)
\family default
 operation is a simple example of something I call a 
\emph on
contract adapter
\emph default
.
 We have one object (
\family typewriter
Zj
\family default
) which implements an 
\begin_inset Quotes eld
\end_inset

I can be qualified with a name and a station index to make a Jones term
\begin_inset Quotes erd
\end_inset

 contract, and another object (the 
\family typewriter
J
\family default
 argument to 
\family typewriter
corrupt()
\family default
) that implements an 
\begin_inset Quotes eld
\end_inset

I can be qualified with a station index to make a Jones term
\begin_inset Quotes erd
\end_inset

 contract.
 The 
\begin_inset Quotes eld
\end_inset


\family typewriter
(src.name)
\family default

\begin_inset Quotes erd
\end_inset

 operation adapts one contract to match the other.
 Happily for us, it really is that simple, which is hardly a coincedence:
 Meow's contracts are designed around TDL's qualification mechanism.
 
\end_layout

\begin_layout Standard
A more somewhat more complicated case arises if we decide to change our
 ionospheric model (i.e.
 the innards of 
\family typewriter
compute_zeta_jones()
\family default
) to eliminate directional dependence.
 The function would then presumably look something like this:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

def compute_zeta_jones_from_tecs (ns,tecs,source_list):
\end_layout

\begin_layout Standard

  """Creates the Z Jones for ionospheric phase,
\end_layout

\begin_layout Standard

  given TECs (per source,   per station).""";
\end_layout

\begin_layout Standard

  zeta = ns.Z;
\end_layout

\begin_layout Standard

  for p in Context.array.stations():
\end_layout

\begin_layout Standard

    zeta(p) << Meq.Polar(1,-25*Lightspeed*tecs(p)/Meq.Freq());
\end_layout

\begin_layout Standard

  return zeta; # really??
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The problem here is that we've gone and changed the contract on the function's
 return value, thus breaking all the scripts that use our model.
 
\end_layout

\begin_layout Standard
There are a few ways around this difficulty.
 The naive way is to add some redundant per-source terms:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  for src in source_list:
\end_layout

\begin_layout Standard

    for p in Context.array.stations():
\end_layout

\begin_layout Standard

      zeta(src.name,p) << Meq.Polar(1,-25*Lightspeed*tecs(p)/Meq.Freq());
\end_layout

\begin_layout Standard

  return zeta;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here we've created a bunch of subtrees that all repeat the same calculation
 over and over.
 This is rather wasteful, especially with a lot of source involved.
 The second approach is to use 
\family typewriter
MeqIdentity
\family default
 nodes:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  for p in Context.array.stations():
\end_layout

\begin_layout Standard

    zeta(p) << Meq.Polar(1,-25*Lightspeed*tecs(p)/Meq.Freq());
\end_layout

\begin_layout Standard

    for src in source_list:
\end_layout

\begin_layout Standard

      zeta(src.name,p) << Meq.Identity(zeta(p));
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This works rather better --- the tree will have a number of redundant 
\family typewriter
MeqIdentity
\family default
 nodes, but since they're effectively a no-op, they will not slow it down
 in any noticeable way.
 
\end_layout

\begin_layout Standard
Finally, there's the purely Pythonic 
\begin_inset Quotes eld
\end_inset

contract adapter
\begin_inset Quotes erd
\end_inset

 approach.
 We can define a little function that behaves like a node stub.
 There's a wrong way and a right way to do this.
 The wrong way goes something like this:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  for p in Context.array.stations():
\end_layout

\begin_layout Standard

    zeta(p) << Meq.Polar(1,-25*Lightspeed*tecs(p)/Meq.Freq());
\end_layout

\begin_layout Standard

  return lambda x:zeta;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\family typewriter
lambda x:zeta
\family default

\begin_inset Quotes erd
\end_inset

 statement creates a function with one argument that returns 
\family typewriter
zeta
\family default
 (and ignores the argument).
 This only half-works with the 
\family typewriter
ME2/example6-iono.py
\family default
 script:
\end_layout

\begin_layout Itemize
the return value --- our lambda function --- gets assigned to 
\family typewriter
Zj.
\end_layout

\begin_layout Itemize
when 
\family typewriter
Zj
\family default
 is invoked as 
\family typewriter
Zj(src.name)
\family default
, the lambda function is called, and returns 
\family typewriter
ns.Z
\family default
.
 This is something that can be qualified with an antenna index inside 
\family typewriter
corrupt()
\family default
, so we're doing good so far.
\end_layout

\begin_layout Itemize
but when 
\family typewriter
Zj
\family default
 is invoked as 
\family typewriter
Zj(src.name,p)
\family default
 a little bit later in the script, the whole thing breaks down since the
 lambda function expects a single argument.
\end_layout

\begin_layout Standard
Our lambda function behaves just like a node stub when invoked as 
\family typewriter
Zj(src.name)(p)
\family default
, but not when invoked as 
\family typewriter
Zj(src.name,p)
\family default
.
 To get things right in both cases, we need a somewhat more sophisticated
 adapter function:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  for p in Context.array.stations():
\end_layout

\begin_layout Standard

    zeta(p) << Meq.Polar(1,-25*Lightspeed*tecs(p)/Meq.Freq());
\end_layout

\begin_layout Standard

  def adapter (name,p=None):
\end_layout

\begin_layout Standard

    z = zeta;
\end_layout

\begin_layout Standard

    if p is not None:
\end_layout

\begin_layout Standard

      z = z(p);
\end_layout

\begin_layout Standard

    return z;
\end_layout

\begin_layout Standard

  return adapter;
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This shows how you can define and return a 
\begin_inset Quotes eld
\end_inset

local
\begin_inset Quotes erd
\end_inset

 function on-the-fly.
 The return value of 
\family typewriter
compute_zeta_jones()
\family default
 is the 
\family typewriter
adapter
\family default
 function.
\begin_inset Foot
status open

\begin_layout Standard
Note that the name 
\family typewriter
adapter
\family default
 is local to 
\family typewriter
compute_zeta_jones()
\family default
 and is not seen anywhere outside that function.
 Other functions can define their own local things called 
\family typewriter
adapter
\family default
 without any confusion.
\end_layout

\end_inset

 When called as 
\family typewriter
adapter(src.name)
\family default
, it returns 
\family typewriter
zeta
\family default
.
 When called as 
\family typewriter
adapter(src.name,p)
\family default
, it returns 
\family typewriter
zeta(p)
\family default
.
 This is exactly the behaviour we want.
\end_layout

\begin_layout Standard
There's an even more elegant to implement this adapter function.
 Note that the operation we're trying to perform here can be reformulated
 in a general way as 
\begin_inset Quotes eld
\end_inset

ignore the first qualifier, apply the rest
\begin_inset Quotes erd
\end_inset

.
 Here's a suitably general implementation:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{verbatim}
\end_layout

\begin_layout Standard

  def adapter (first_qual,*other_quals):
\end_layout

\begin_layout Standard

    return zeta(*other_quals);
\end_layout

\begin_layout Standard


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this particular scenario, it is really only a matter of taste whether
 you go for the 
\family typewriter
MeqIdentity
\family default
 nodes approach, or the (more Pythonic) contract adapter approach.
 In my opinion, the latter is more elegant, and is an essential technique
 to master, as it really comes into its own once you get into more complicated
 territory.
 To summarize:
\end_layout

\begin_layout Itemize
Python encourages you to consider objects in terms of their behaviour rather
 than their type.
 Using this wisely leads to more flexible interfaces and cleaner code.
\end_layout

\begin_layout Itemize
The essence of design by contract is to think in terms of behaviour, not
 type.
 For example, rather than thinking of the return value of a function as
 an unqualified node, think of it as 
\begin_inset Quotes eld
\end_inset

a thingy that can be qualified by a source name and a station index to derive
 a node
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Python makes it easy to write little adapters that make one object behave
 like another.
\end_layout

\begin_layout Section
Meow and node tags
\end_layout

\begin_layout Standard
**** to be continued ***
\end_layout

\end_body
\end_document
