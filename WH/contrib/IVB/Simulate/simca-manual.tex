\documentclass[11pt]{article}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   % ... or a4paper or a5paper or ... 
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}
\parindent=0pt

\title{SIMulation and CAlibration in MeqTree:\\ My personal 06RX51 manual}
\author{Me myself \& I}
\date{\today}                                           % Activate to display a given date or no date

\begin{document}
\maketitle

\section{TDL compile and runtime options}\label{options}
The TDL options allow the user to select or unselect certain functionality or input to the script. The compiler options do this for the compile step and the runtime options for the actual run. With the Calico and Meow frameworks a lot of the TDL options are automatically set. In addition the user can set his own options. The options settings are saved in a file .tdl.conf in the working directory. When the script is opened again, the options are set as they were in the last compile. To get rid of errors, remove the .tdl.conf file and restart the MeqBrowser completely. More details on setting options is found on the MeqWiki:
http://www.astron.nl/meqwiki/TdlOptions and http://www.astron.nl/meqwiki/TdlOptions/SmartOptions

\section{MeqMaker}\label{meqmaker}
The MeqMaker script generates the sky model and apllies certain Jones matrices. It defines a class MeqMaker which looks for certain pre-defined modules in the scripts from which it will construct the sky model and builds the predict tree. It takes care of the inspectors and imaging settings as well. The MeqMaker can be called with the argument solvable (boolean). This argument is False for the scripts that only need to simulate.

The main routine in MeqMaker is make\_predict\_tree. The arguments to this function are sources and stations. The station list is generated from Context.array.stations if none is provided. The source list is generated from the sky model provided. It builds the predict-tree that applies the Jones terms to the plain sky. It distinguishes between sky-Jones and {\it uv}-Jones matrices. The other important routine is correct\_uv\_data, which applies the solver corrections to the {\it uv}-data.

\subsection{Adding the plain sky model}\label{sources}
MeqMaker generates the undisturbed sky model from any given source and makes the according TDL options in the compile menu if needed. The function add\_sky\_models reads from a list of models and generates the TDL compile option that allows the user to select a specific model.

In the Calico subdirectory there is a simple script to define a central point-source, but Meow also has the option to read from a LSM file using the LSM.py script. This script automatically generates the necessary TDL options to select a file and format. Current formats for reading are native (*.lsm), newstar (*.mdl), NVSS, clean (using clean components), text file (locations in radians or DMS) or VizieR. The script also creates a TDL option to show the LSM GUI, which is set to False by default, the maximum number of sources to be used, and which source parameters are to be solvable.

The function source\_list reads the LSM file and returns a list of Meow objects. By default they are point sources. If sources have a Gaussian fit which is provided, then Gaussians are returned (I don't see where and how these can be provided ATM).

\subsection{Adding Jones terms}
The MeqMaker class has subclass JonesTerm which is a record representing one Jones term. Each Jones term will generate its own entry in the TDL compile menu and can be toggled on or off. It will also get its own inspector in the Bookmarks menu. It has the fields:
\begin{itemize}
\item label: a brief label which is used for the naming of the NodeStub, such as the main Jones term capital letter (e.g E or G)
\item name: a descriptive name, such as "ionosphere", not used for anything but clarity
\item module: the name of a module that returns the actual Jones matrix. This module has to contain the function compute\_jones.
\end{itemize}
There is a specific class SkyJonesTerm which has a pointing\_module field in addition to the JonesTerm fields. This field contains the pointing error modules. 

In order to distinguish between {\it uv}-Jones and sky-Jones terms, the script keeps a record. To specify a Jones matrix as {\it uv}-Jones the function add\_uv\_jones is called. To add a sky-Jones, use add\_sky\_jones.
The call specifies the label, name and list of modules (which {\em have} to contain the function compute\_jones. For example:
\begin{verbatim}
meqmaker=MeqMaqker.MeqMaker(solvable=True)
meqmaker.add_sky_jones('Z','ionosphere',[solvable_ionosphere.Iono()]
\end{verbatim}

\section{Setting the Context}\label{context}
Meow has a routine Context.py which will setup the context of the observations by reading basic parameters from the MS. It defines the array, observation, and phase center. Note that the sources are {\em not} part of the context, they are treated seperately in the section~\ref{sources}. Context also knows the global variables vdm and mssel, which define the VisDataMux and selected MS, but does not do anything with them. Context has the following subroutines:
\begin{itemize}
\item set: to set the global Meow context
\item get\_array: reads the array parameters from the MS
\item get\_observation: reads the observing parameters from the MS
\item get\_dir0: reads the phase centre from the MS
\end{itemize}

Context returns the following:
\begin{itemize}
\item Context.array: coordinates for the array in ITRF
\item Context.observation: ?
\item Context.observation.phase\_centre: RA and DEC of the phase centre.
\end{itemize}

\section{Reading the Measurement Set}\label{ms}
To get all the proper values into Context, a MS is needed. Meow routine MSUtils.py is used to read and set all the proper MS parameters for MeqTree. It allows selection of a subset of a MS, this is not described here (routine variables ddid and field). It defines a class MSSelector which implements TDL options (see section~\ref{options}) for selecting  the MS (and a subset). The arguments to the MSSelector call are:
\begin{itemize}
\item     filter:     ms name filter. Default is *.ms *.MS (keep in mind the MS is a directory)
\item    has\_input:  is an input column selector initially enabled.
\item    has\_input:  is an output column selector initially enabled.
\item    forbid\_output: a list of forbidden output columns. DATA by default.
\item    antsel:     if True, an antenna subset selector will be provided
\item    tile\_sizes: list of suggested tile sizes. If false, no tile size selector is provided.
\item    ddid:       list of suggested DDIDs, or false for no selector.
\item    field:      list of suggested fields. or false for no selector.
      NB: if pycasatable is available, ddid/field is ignored, and selectors are always
      provided, based on the MS content.
\item    channels:   if True, channel selection will be provided
\item    flags:      if True, a write flags option will be provided
\item    hanning:    if True, an apply Hanning tapering option will be provided
\item    namespace:  the TDLOption namespace name, used to qualify TDL options created here.         If making multiple selectors, you must give them different namespace names.
\end{itemize}

After calling the MSselector, the TDLOptions need to be specified as global TDL compiler and runtime options. An example to set-up the MS options in TDL could look like this:
\begin{verbatim}
mssel = Context.mssel = Meow.MSUtils.MSselector(has_input=True, tile_sizes=None, 
  flags=False, hanning=True)
TDLCompileOptions(*mssel.compile_options())
TDLRuntimeMenu("MS  and data selection options",*mssel.runtime_options())
\end{verbatim}

Note that the MSUtils.py also contains the ImagingSelector objects, which is discussed later.



%\subsection{}



\end{document}  