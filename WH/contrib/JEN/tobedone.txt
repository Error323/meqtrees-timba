file: ../WH/contrib/JEN/tobedone.txt
                                      last changed:   d31dec

NB: Just temporary: To be converted into Bugzilla items....! 



==================================================================

detected bugs:

 - 31dec2005: ReqMux does not work!! 
   Error mssage: nmandatory<=nchildren (see MG_JEN_Cohset.py)
   Rebuild, and try again.......

 - NB: Discuss new hcoll_metrics with WNB

 - AGW fax: 1-250-4937767

==================================================================



 - MXM: Read MG inputs from a file
   - Otherwise, have to adapt custom values after each cvs update
   - A step towards inarg-file-driven (sequences of) MG scripts 
   - Need an inarg GUI...

 - JEN: TDL_Cohset.py: 
   - arrange for proper treatment of XX/YY only (etc)        done
   - selfcal for WHAT with WSRT XY/YX (14 only)
   - update from Sixpack (like from Joneset)       <----
     - This requires solvegroups in Sixpack                  TDL_Parmset.py

 - JEN: MG_JEN_Cohset::visualise()
   - Make a realvsimag/spectra mode that shares stripper nodes etc

 - JEN: MG_JEN_Joneset::visualise()
   - streamline a bit....

 - JEN: MG_JEN_Joneset.py:
   - dissimilar station (WHAT) 
 - JEN: TDL_Joneset.py:
   - dissimilar station (WHAT): no impact?
   - more transparent or default... (MXM)...?
   - Use scalar default values (0,1)
   - Allow later specification of shape (also via Joneset?)
   - Allow ND funklets......!

 - JEN: TDL_Parmset.py 
   - A Joneset/Cohset/Sixpack object contains a Parmset object

 - GVD: MeqTree testing
   - when using a subset of the MS, the tree is still made for all ifrs
     (however, it does not fail....)

 - MXM/JEN/SBY: Tools for funklet creation.....
 - SBY/OMS: Domain dimensions.....

 - MXM: MeqParm default value discussion
   - separate default values from solve-shape      <----- !!
   - JEN proposal:
     - The scheme should be internally consistent: NO MORE KLUDGES!!
     - allow SCALAR default value only (default = 0.0)
       (only a scalar does not need a validity domain)
     - set the solve-shape when setting the MeqParm solvable
       - done by the Solver, using the rider
       - specify when creating the solver? how?
         - can only specify nr of coeff in each dimension,
           but NOT their values since that would require a validity domain,
           which we do not know. So the initial values should be zero?
           In that case, what about continuity?
       - change (dynamically?) afterwards?
       - NB: Can a MeqParm have funklets with different nrs of dimensions...?  
   - MXM: Treat polcs as different from funklets, i.e. funklets are NOT
          a generalisation of polcs....!?

 - MXM/JEN: MeqParm/solver modes
   - ALWAYS return values, arbitrary request
     - interpolations scheme
     - more efficient if successive/cotiguous domains?
     - mix of funklets with different dimensions?
     - also used for finding initial value for solving?
   - snippet-by-snippet solution
     - Always tiled solution (tile_size=1)?
     - MeqParm intelligence (growing domain)
       - Prediction of next value (convergence)
       - rejection of 'bad' solutions
       - more efficient table use (fewer polcs)
       - no extra cost if accumulating solution matrix
       - how to decide when to start new polc? overlap?
     - Smoothing of table polcs/funklets afterwards
       - simpler (more versatile?) scheme than above
       - has to be done in any case (edge discontinuities)
       - better rejection of 'bad' solutions (more info)
       - use last value as prediction for the next (almost as good)

 - MXM/JEN: BJones (Abell963)
   - Alternative:
     - solve for BJones on the central source, dt = 1 hr
       - takes care of slowly time-variable BJones
       - contamination from the other sources?
     - correct the uv-data for this BJones
     - solve for GJones on the central source, dt = 1 min
       - rapid gain variations, w.r.t. slow BJones
     - subtract the (corrupted) central source 
     - correct the uv-data for this GJones
   - Alternative: 
     - First GJones (1 min), then BJones (1 hour)
     - Allows flagging (provisory subtract!)           <===== !!
     - Does this produce the correct BJones(f,t)?
   - Alternative:
     - Simultaneous GJones(1min), and BJones(1hr)
     - better, but larger matrix
   - in all cases:
     - MS tile-size must be one hour
     - different MeqParm solution tile-sizes
     - Need independent Sixpacks for the same source   <===== !!
       for GJones/BJones solutions                  
   - then what?
     - position-dependent GJones 
       - extended source: requires uvbrick
     - position-dependent BJones? (very diffifult)

 - MXM/JEN: separate solvers
   - BJones/GJones: use Gpol1, GPol2 separately?
   - automatic?
   - reqseq structure?

 - Reduction sequence:
   - Desirable: one-button operation
     - No manual MeqParm tree operations (intelligent MeqParm, etc)
     - Multiple spigot2sink operations?
       - between different MS columns

 - Resampling (Sarod):
   - get it to work (
   - improvement in speed?
   - degradation of the solution quality?
   - clashes with tiled solutions?
   - dynamic re-specification?

 - SBY: LSM files for WSRT calibrator fields
   - LSM node naming for (saved) LSM's
   - multiple versions of the same LSM in same tree (RJN)?

 - create_MS_interface_nodes()
   - split off the uv-coordinate nodes spec
   - need different set for different directions
     - but ONLY if the uv-data phase-centre has been shifted...?
     - MAB: For point sources, the uvw-coord for the pointing centre
       are correct. But for extended sources, things are different...
   - create a default set for the MS pointing centre (q=uvp?)

 - JEN: MG_JEN_peeling.py
   - correct the data for uv-plane effects (if available) first
     - GJones, BJones, DJones
   - solve for instrumental errors in the direction of peeling sources
     RELATIVE to uv-plane effects (also good diagnostic!)
   - Advantages:
     - uv-data are fit to make a reasonable map from
     - relative errors are sensitive diagnostic
     - convergence is quicker (start closer to solution)
     - just subtract (mildly corrupted) sources
     - no further uv-data correction needed   


 - SvdT: Webpage for script/object inspection
 - SvdT/OMS/MAB: Automatic module testing (3 levels)

 - JEN/SBY/GVD: WSRT/WHAT reduction
   - MG_JEN_Joneset: station-by-station specification
   - 4 WHAT tiles in fixed time-pattern
     - treat them as the same one 
       - position errors absorbed in phases
     - read in together (tile_size=4), and then...?
     - have 4 different trees, and switch between them (how?)
   - step either the WHAT or WSRT around the source (corr.coeff)
     - can we get/assume the RA,DEC pattern?
     - solving for WSRT/WHAT beams
     - visualising beamshapes
     - predicting projected dipole orthogonality


 - OMS/MXM: Sink 'tiling' in freq direction too...
 -      Has repercussions for MeqParm tables...
 - MXM/JEN: MeqParm functional/final description

 - MXM/WNB: Experiment with AIPS++ fitting improvements
 - AGW/JEN: Use LM parameter in 'debug' field of result

 - JEN: TDL_Antenna.py
   - Multiplication of voltage beams (rather than subtract)

 - JEN: TDL_common.py
   - Add a profiler of some kind (Why is Antenna tree definition so slow?)

 - JEN: TDL_result.py (object that dissects a result...)

 - JEN: TDL_display_subtree.py (from MG_JEN_exec.py)
 - JEN: TDL_display_nodescope.py (from MG_JEN_exec.py)
 - JEN: TDL_display_record.py (from MG_JEN_exec.py)

 - JEN: TDL_parameter_set.py (a record of function parameters)

 - JEN: Implement redundancy calibration
   - Future: weak redundancy 
     - Use 3rd (weight) child of condeqs
     - Use telescope positions MSauxinfo
   - WSRT: 
     - Mohset = measured.copy()
     - Mohset.correct(Joneset)
     - Pohset = Mohset.copy()   # Pohset is a copy of the corrected Mohset!
     - Pohset.rxyz_WSRT(): Make baseline lengths per ifr
     - Pohset.redun_WSRT(): Replace each ifr with 'predicted'
       - The next one with the same rxyz 
       - The Mean of all (the other?) ifrs with the same rxzy
     - Pohset.Condeq(Mohset)

 - WNB: Weak reduncancy:
   - weight = cos(duv):
     - weight=1 for duv=0 (strong redundancy)
     - weight<=0 for |duv|>something (3rd condeq child)
     - cutoff for duv=dish diameter?
   - weight(duv) should NOT depend on baseline length (ruv)
     - corrugation length is the same everywhere
   - w(duv) can be wider if the visibility function is smoother
     - if the dominating sources are near the field centre
     - if the remaining sources are uniformly distributed
     - subtract the brightest few sources first?
     - is there a way to estimate the smoothness?      <-----!!
   - Even strong redundancy (duv=0) has its limitations
     - if the antenna voltage beams do not see the same sky (l,m,freq)
     - NB: WSRT pointing is now better than 10 mdeg

 - Stefan: Station redundancy calibration (AGB)
   - Tile-tile sensitivity: 20 Jy @ 10s/10kHz
     - not many point sources visible
     - use the galaxy (visible only for baselines < few lambda
   - integrate a little longer to get S/N>3 
     - apply corrections SMOOTHLY!                <---- !!
       - indistinguishable from temp variations
   - antenna beam differences cause them to see different skies
     - it will be an improvement nevertheless
     - we can learn about mutual coupling from the residuals....
   - ionospheric variations are invisible to redundancy scheme
   - Implemented already: 
     - Kramer-Rao bound better than 1 (noise interpreted as station err)

 - AGB: EoR calibration issues (14 dec):
   - Limited part of the sky (3 fields): GSM is 'known' at some point
   - Short baselines only (most of the time)
   - 10 kHz resolution 
   - on-line calibration: 
     - only ionosphere, assume known LSM and stable beamshapes
     - then integrate to (10,10)
   - Data integration:
     - dt=1s and df=10kHz form a pair 
       (both 10^-4, in radial and transverse direction) 
     - similarly, (10s,100kHz) are a pair, but 100 kHz is too much
     - Need to remove 3 kHz airplane spikes, separated by 8.3 kHz
       - measured by DZB recirculation, with resolution of 150 Hz
       - very strong spike 1 kHz wide
       - much lower wings 3-5 kHz wide, but way above the noise
       - AJB thinks about removing them, before integration to 10 kHz
         - Is there some RFI compensation scheme?
     - Need to correct for ionosphere, before integrating to 10 sec
   - In contrast:
     - Transients may want to store(!) (10s,10kHz) data, just like Eor
     - Surveys have to find LSM sources in each 2 deg field
       - 3C/4C is not sufficient, expect 3-5 sources > 1 Jy per field
     - Both use the long baselines also


 - RJN: uvbrick
   - distributing point source over adjacent grid points
     - makes it an extended source
     - but smaller than the observation resolution
   - moving point source to the nearest grid point
     - causes it to be subtracted at the wrong position
       (but within the observation resolution!)
     - does not affect the selfcal solution very much
   - do we need multiple w-planes?
   - separate the w-effects from interpolation effects
   - for the moment:
     - move point sources to nearest grid point
     - dont do anything for extended sources
     - FFT to single w-plane, and interpolate (linearly?) 
     - study the error effects in the residual images
       - think of refinements from there onwards 
     - develop the application of image-plane effects via interpolation

 - AGW/WNB: hcoll, especially solver metrics
   - combine non-matching arrays
   - concatenate in the time direction (sawtooth)
   - put vectors into the same plot (comparison)

 - JEN: Contamination filtering

 - JEN: Contamination reduction
   - Subtract all the nominal sources at the start (at full resolution)
   - For each peeling step, add one source, and then subtract it
   - Reuse predicted sources as much as possible

 - JEN: Automatic search for contaminating sources
   - Use RADAR
     - Matrix of test sources (LSM)
     - let them walk to the correct positions
     - short baselines first... (they 'see' further)

 - Sarod: LSM
   - copy NVSS text-file to home directory (?): abel963.txt
     - scp mevius@birch:/home/mevius/LSM_read.py . 
       - requires a password...! 
   - use: python LSM_read.py to make LSM object
     - NB: This seems to have abel963.txt hard-coded...
   - the LSM object shows itself as an image
   - save it as abel963.lsm



==========================================================================
============ Some useful MG scripts that we might make ===================
==========================================================================

 - MG_JEN_lsm2apparent.py
   - takes an LSM (e.g. an intrinsic one from NVSS)
   - makes a new LSM with apparent source parameters
   - useful for peeling, etc
   - solve for source fluxes 
     - one single domain for the entire observation
     - incl SI (subsumes voltage beam freq dependence)...
   - option: solve simultaneously for overall (uvp) GJones?
     - do not solve for the flux of the brightest source (reference) 
     - option: slow time variation only (tiled solutions)
     - NB: This is BJones rather than GJones
       - Do rapid variation GJones (phase) later?
   - NB: All this works best for WSRT (equatorial)
   
  
 - MG_JEN_EJones.py
   - solves for voltage beamshapes (EJones)
   - takes an intrinsic LSM (e.g. from NVSS)
   - one single domain for the entire observation
   - assume that beam coeff are constant in time
     - or changing slowly in time (tiled solutions)  
   - assume linear freq dependence 
   - Need an EJones funklet (4D beamshape model)
   - 17 MHz ripple



                      ================================
