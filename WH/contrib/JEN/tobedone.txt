file: ../WH/contrib/JEN/tobedone.txt
                                      last changed:   d09dec

NB: Just temporary: To be converted into Bugzilla items....!

 - JEN: TDL_Cohset.py: 
   - arrange for proper treatment of XX/YY only (etc)
   - selfcal for WHAT with WSRT XY/YX (14 only)

 - JEN: MG_JEN_Joneset.py:
   - dissimilar station (WHAT) 
 - JEN: TDL_Joneset.py:
   - dissimilar station (WHAT): no impact?
   - more transparent or default... (MXM)...?
   - Use scalar default values (0,1)
   - Allow later specification of shape (also via Joneset?)
   - Allow ND funklets......!

 - MXM/JEN/SBY: Tools for funklet creation.....
 - SBY/OMS: Domain dimensions.....

 - MXM: MeqParm default value discussion
   - separate default values from solve-shape      <----- !!
   - JEN proposal:
     - The scheme should be internally consistent: NO MORE KLUDGES!!
     - allow SCALAR default value only (default = 0.0)
       (only a scalar does not need a validity domain)
     - set the solve-shape when setting the MeqParm solvable
       - done by the Solver, using the rider
       - specify when creating the solver? how?
         - can only specify nr of coeff in each dimension,
           but NOT their values since that would require a validity domain,
           which we do not know. So the initial values should be zero?
           In that case, what about continuity?
       - change (dynamically?) afterwards?
       - NB: Can a MeqParm have funklets with different nrs of dimensions...?  
   - MXM: Treat polcs as different from funklets, i.e. funklets are NOT
          a generalisation of polcs....!?

 - MXM/JEN: MeqParm/solver modes
   - ALWAYS return values, arbitrary request
     - interpolations scheme
     - more efficient if successive/cotiguous domains?
     - mix of funklets with different dimensions?
     - also used for finding initial value for solving?
   - snippet-by-snippet solution
     - Always tiled solution (tile_size=1)?
     - MeqParm intelligence (growing domain)
       - Prediction of next value (convergence)
       - rejection of 'bad' solutions
       - more efficient table use (fewer polcs)
       - no extra cost if accumulating solution matrix
       - how to decide when to start new polc? overlap?
     - Smoothing of table polcs/funklets afterwards
       - simpler (more versatile?) scheme than above
       - has to be done in any case (edge discontinuities)
       - better rejection of 'bad' solutions (more info)
       - use last value as prediction for the next (almost as good)

 - MXM/JEN: BJones (Abell963)
   - Alternative:
     - solve for BJones on the central source, dt = 1 hr
       - takes care of slowly time-variable BJones
       - contamination from the other sources?
     - correct the uv-data for this BJones
     - solve for GJones on the central source, dt = 1 min
       - rapid gain variations, w.r.t. slow BJones
     - subtract the (corrupted) central source 
     - correct the uv-data for this GJones
   - Alternative: 
     - First GJones (1 min), then BJones (1 hour)
     - Allows flagging (provisory subtract!)           <===== !!
     - Does this produce the correct BJones(f,t)?
   - Alternative:
     - Simultaneous GJones(1min), and BJones(1hr)
     - better, but larger matrix
   - in all cases:
     - MS tile-size must be one hour
     - different MeqParm solution tile-sizes
     - Need independent Sixpacks for the same source   <===== !!
       for GJones/BJones solutions                  
   - then what?
     - position-dependent GJones 
       - extended source: requires uvbrick
     - position-dependent BJones? (very diffifult)

 - MXM/JEN: separate solvers
   - BJones/GJones: use Gpol1, GPol2 separately?
   - automatic?
   - reqseq structure?


 - Resampling:
   - improvement in speed?
   - degradation of the solution quality?
   - clashes with tiled solutions?
   - dynamic re-specification?

 - SBY: LSM files for WSRT calibrator fields
   - LSM node naming for (saved) LSM's
   - multiple versions of the same LSM in same tree (RJN)?

 - create_MS_interface_nodes()
   - split off the uv-coordinate nodes spec
   - need different set for different directions
     - but ONLY if the uv-data phase-centre has been shifted...?
     - MAB: For point sources, the uvw-coord for the pointing centre
       are correct. But for extended sources, things are different...
   - create a default set for the MS pointing centre (q=uvp?)

 - JEN: MG_JEN_peeling.py
   - correct the data for uv-plane effects (if available) first
     - GJones, BJones, DJones
   - solve for instrumental errors in the direction of peeling sources
     RELATIVE to uv-plane effects (also good diagnostic!)
   - Advantages:
     - uv-data are fit to make a reasonable map from
     - relative errors are sensitive diagnostic
     - convergence is quicker (start closer to solution)
     - just subtract (mildly corrupted) sources
     - no further uv-data correction needed   


 - SvdT: Webpage for script/object inspection
 - SvdT/OMS/MAB: Automatic module testing (3 levels)

 - JEN/SBY/GVD: WSRT/WHAT reduction
   - MG_JEN_Joneset: station-by-station specification
   - 4 WHAT tiles in fixed time-pattern
     - treat them as the same one 
       - position errors absorbed in phases
     - read in together (tile_size=4), and then...?
     - have 4 different trees, and switch between them (how?)
   - step either the WHAT or WSRT around the source (corr.coeff)
     - can we get/assume the RA,DEC pattern?
     - solving for WSRT/WHAT beams
     - visualising beamshapes
     - predicting projected dipole orthogonality


 - OMS/MXM: Sink 'tiling' in freq direction too...
 -      Has repercussions for MeqParm tables...
 - MXM/JEN: MeqParm functional/final description

 - MXM/WNB: Experiment with AIPS++ fitting improvements
 - AGW/JEN: Use LM parameter in 'debug' field of result

 - JEN: TDL_Antenna.py
   - Multiplication of voltage beams (rather than subtract)

 - JEN: TDL_common.py
   - Add a profiler of some kind (Why is Antenna tree definition so slow?)

 - JEN: TDL_result.py (object that dissects a result...)

 - JEN: TDL_display_subtree.py (from MG_JEN_exec.py)
 - JEN: TDL_display_nodescope.py (from MG_JEN_exec.py)
 - JEN: TDL_display_record.py (from MG_JEN_exec.py)

 - JEN: TDL_parameter_set.py (a record of function parameters)

 - Stefan: Station redundancy calibration (AGB)
   - Tile-tile sensitivity: 20 Jy @ 10s/10kHz
     - not many point sources visible
     - use the galaxy (visible only for baselines < few lambda
   - integrate a little longer to get S/N>3 
     - apply corrections SMOOTHLY!                <---- !!
       - indistinguishable from temp variations
   - antenna beam differences cause them to see different skies
     - it will be an improvement nevertheless
     - we can learn about mutual coupling from the residuals....
   - ionospheric variations are invisible to redundancy scheme
   - Implemented already: 
     - Kramer-Rao bound better than 1 (noise interpreted as station err)

 - AGB: EoR calibration issues (14 dec):
   - Limited part of the sky (3 fields): GSM is 'known' at some point
   - Short baselines only (most of the time)
   - 10 kHz resolution 
   - on-line calibration: 
     - only ionosphere, assume known LSM and stable beamshapes
     - then integrate to (10,10)
   - Data integration:
     - dt=1s and df=10kHz form a pair 
       (both 10^-4, in radial and transverse direction) 
     - similarly, (10s,100kHz) are a pair, but 100 kHz is too much
     - Need to remove 3 kHz airplane spikes, separated by 8.3 kHz
       - measured by DZB recirculation, with resolution of 150 Hz
       - very strong spike 1 kHz wide
       - much lower wings 3-5 kHz wide, but way above the noise
       - AJB thinks about removing them, before integration to 10 kHz
         - Is there some RFI compensation scheme?
     - Need to correct for ionosphere, before integrating to 10 sec
   - In contrast:
     - Transients may want to store(!) (10s,10kHz) data, just like Eor
     - Surveys have to find LSM sources in each 2 deg field
       - 3C/4C is not sufficient, expect 3-5 sources > 1 Jy per field
     - Both use the long baselines also

      
   



                      ================================
