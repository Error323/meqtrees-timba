# ../Timba/PyApps/test/WSRT_cps.tdl:  
#   MeqForests for WSRT Central Point Source (cps) reduction

print '\n',100*'*'
print '** WSRT_cps.tdl    h30jul/d17aug2005'

# standard preamble
from Timba.TDL import *
from Timba.Meq import meq
from numarray import *

# WSRT related modules:
from WSRT_jones import *
from WSRT_coh import *
# from WSRT_calibrators import *
# Better: put the WSRT stuff in a sub-directory....
# from WSRT.WSRT_jones import *
# from WSRT.WSRT_coh import *




#================================================================================
# The forest state record will be included automatically in the tree.
# Just assign fields to: Settings.forest_state[key] = ...
#================================================================================

from JEN_forest_state import *

JEN_forest_state_init('WSRT_cps')


#================================================================================
# The main routine:
#================================================================================

def _define_forest (ns):
  simul = True                                # if True, use simulated uv-data
  flag = False                                   # if True, add noise and flag
  trace = True                                # if True, trace execution

  stations = range(0,5)
  ifrs  = [ (s1,s2) for s1 in stations for s2 in stations if s1<s2 ]

  punit = 'QU'
  punit = 'unpol'

  # Default values for instrumental errors
  phase = 0
  ampl = 1
  dang = 0
  dell = 0

  # Get a real or simulated cohset (for all ifrs):
  if not simul:
    cohset = coh_spigots (ns, ifrs=ifrs, trace=trace)

  else:
    nsim = ns.Subscope('_')                               # prepend simulated nodes with _::
    punit_simul = punit                                         # simulated source
 
    JJ = []                                                                # list of 2x2 Jones matrices
    phase = array([[0,-0.1],[0.1,0]])  
    ampl = array([[1,-0.1],[0.1,0]])  
    JJ.append (WSRT_GJones (nsim, stations=stations, punit=punit_simul, 
                       phase=phase, ampl=ampl, 
                       stddev_phase=0.2, stddev_ampl=0.3,
                       solvable=0, trace=trace))
    dang = array([[0,0.01],[0.01,0]])  
    dell = array([[0,0.01],[0.01,0]])  
    # JJ.append (WSRT_DJones (nsim, stations=stations, punit=punit, dang=dang, dell=dell, solvable=0, trace=trace))
    JJ_simul = JJ[0]
    JJ_simul = WSRT_JJones (nsim, JJ)
    cohset = coh_predict (nsim, source=punit, ifrs=ifrs, corrupt=JJ_simul, trace=trace)
    JJ_predict = JJ_simul                                 # used in coh_correct below

  # Operations on the cohset:
  if flag: cohset = coh_addnoise (ns, cohset, stddev=1, unop='Exp', trace=trace)
  cohset = coh_visualise(ns, cohset, scope='rawdata', errorbars=False, trace=trace)
  if flag: cohset = coh_insert_flagger (ns, cohset, scope='rawdata', sigma=1, unop='Abs', visu=True, trace=trace)

  
  # Optional: insert a solver:
  if 1:
    JJ = []                                               # list of 2x2 Jones matrices
    # phase = array([[0,-0.1],[0.1,0]])  
    # ampl = array([[1,-0.1],[0.1,0]])  
    JJ.append (WSRT_GJones (ns, stations=stations, punit=punit, phase=phase, ampl=ampl, trace=trace))
    dang = array([[0,0.01],[0.01,0]])  
    dell = array([[0,0.01],[0.01,0]])  
    # JJ.append (WSRT_DJones (ns, stations=stations, punit=punit, dang=dang, dell=dell, trace=trace))
    JJ_predict = JJ[0]
    JJ_predict = WSRT_JJones (ns, JJ)
    predicted = coh_predict (ns, source=punit, ifrs=ifrs, corrupt=JJ_predict, trace=1)

    pgroup = 'Gphase'
    pgroup = 'Gampl'
    pgroup = 'GX'
    pgroup = 'GJones'
    coh_solver (ns, name=pgroup, measured=cohset, predicted=predicted, num_iter=10, trace=1) 

  # Optional: correct
  if 1: 
    cohset = coh_correct (ns, cohset, joneset=JJ_predict, trace=trace)
    cohset = coh_visualise (ns, cohset, scope='corrected', trace=trace)

  # Finished:
  if simul:
    coh_simul_sink (ns, cohset, trace=trace)
  else:
    print

  # Display the accumulated forest history (in forest state record)
  JEN_forest_history(show=True)


#================================================================================
# Test routine:
#================================================================================

def _test_forest (mqs, parent):
  """test_forest() is a standard TDL name. When a forest script is
  loaded by, e.g., the browser, and the "test" option is set to true,
  this method is automatically called after define_forest() to run a 
  test on the forest. The 'mqs' argument is a meqserver proxy object.
  """;
  from Timba.Meq import meq

  # run test on the forest
  cells = meq.cells(meq.domain(0,1,0,1),num_freq=6,num_time=4);
  request = meq.request(cells,eval_mode=0);
  # mqs.meq('Debug.Set.Level',record(debug_level=100));
  # mqs.meq('Node.Set.Breakpoint',record(name='solver:GJones:q=uvp',breakpoint=255));
  mqs.meq('Node.Execute',record(name='simul_sink',request=request));

  # Use the savefile from the forest state record
  mqs.meq('Save.Forest',record(file_name=JEN_forest_savefile()+'.meqforest'));	



#================================================================================
# Test routine:
#================================================================================
# this is a useful thing to have at the bottom of the script, 
# it allows us to check the tree for consistency
# simply by running 'python script.tdl'

if __name__ == '__main__':
  ns = NodeScope()
  define_forest(ns)
  # resolves nodes
  ns.Resolve()	
  print len(ns.AllNodes()),'nodes defined';
