//## begin module%1.4%.codegen_version preserve=yes
//   Read the documentation to learn more about C++ code generator
//   versioning.
//## end module%1.4%.codegen_version

//## begin module%3C10CC830067.cm preserve=no
//	  %X% %Q% %Z% %W%
//## end module%3C10CC830067.cm

//## begin module%3C10CC830067.cp preserve=no
//## end module%3C10CC830067.cp

//## Module: NestableContainer%3C10CC830067; Package specification
//## Subsystem: DMI%3C10CC810155
//	f:\lofar\dvl\lofar\cep\cpa\pscf\src
//## Source file: f:\lofar\dvl\lofar\cep\cpa\pscf\src\NestableContainer.h

#ifndef NestableContainer_h
#define NestableContainer_h 1

//## begin module%3C10CC830067.additionalIncludes preserve=no
#include "Common.h"
#include "DMI.h"
//## end module%3C10CC830067.additionalIncludes

//## begin module%3C10CC830067.includes preserve=yes
#include "TypeInfo.h"
//## end module%3C10CC830067.includes

// Registry
#include "Registry.h"
// HIIDSet
#include "HIIDSet.h"
// BlockableObject
#include "BlockableObject.h"
//## begin module%3C10CC830067.declarations preserve=no
//## end module%3C10CC830067.declarations

//## begin module%3C10CC830067.additionalDeclarations preserve=yes
using Debug::ssprintf;
//## end module%3C10CC830067.additionalDeclarations


//## begin NestableContainer%3BE97CE100AF.preface preserve=yes
class NestableContainer;
//## end NestableContainer%3BE97CE100AF.preface

//## Class: NestableContainer%3BE97CE100AF; Abstract
//## Category: PSCF::DMI%3BEAB1F2006B; Global
//## Subsystem: DMI%3C10CC810155
//## Persistence: Transient
//## Cardinality/Multiplicity: n



//## Uses: <unnamed>%3BFBAF8303C0;HIIDSet { -> }
//## Uses: <unnamed>%3C5A7A4400BF;UniRegistry { -> }

class NestableContainer : public BlockableObject  //## Inherits: <unnamed>%3BFCD87C0106
{
  //## begin NestableContainer%3BE97CE100AF.initialDeclarations preserve=yes
  //## end NestableContainer%3BE97CE100AF.initialDeclarations

  public:
    //## begin NestableContainer::ConstHook%3C614FDE0039.preface preserve=yes
    //## end NestableContainer::ConstHook%3C614FDE0039.preface

    //## Class: ConstHook%3C614FDE0039
    //	ConstHook/Hook are helper classes generated by the [id] and  [n]
    //	operators. Hooks implements assignment and conversion operators for
    //	data elements.
    //## Category: PSCF::DMI%3BEAB1F2006B; Global
    //## Subsystem: DMI%3C10CC810155
    //## Persistence: Transient
    //## Cardinality/Multiplicity: n



    class ConstHook 
    {
      //## begin NestableContainer::ConstHook%3C614FDE0039.initialDeclarations preserve=yes
      //## end NestableContainer::ConstHook%3C614FDE0039.initialDeclarations

      public:
        // Additional Public Declarations
          //## begin NestableContainer::ConstHook%3C614FDE0039.public preserve=yes
          friend NestableContainer;
      
          // pull in const accessdor methods
          #include "DataAcc-Const.h"

          // address-of operator   
          const ConstHook & operator & () const;
          
          // subscript operators
          const ConstHook & operator [] (const HIID &id) const;
          const ConstHook & operator [] (const string &id) const 
                            { return (*this)[HIID(id)]; } 
          const ConstHook & operator [] (const char *id) const
                            { return (*this)[HIID(id)]; } 
          const ConstHook & operator [] (int n) const;
          
          TypeId type () const;
          
          // standard debug info
          string sdebug ( int detail = 1,const string &prefix = "",const char *name = "cHook" ) const;
          const char *debug ( int detail = 1,const string &prefix = "",const char *name = "cHook" ) const
          { return Debug::staticBuffer(sdebug(detail,prefix,name)); }

          //## end NestableContainer::ConstHook%3C614FDE0039.public
      protected:
        // Additional Protected Declarations
          //## begin NestableContainer::ConstHook%3C614FDE0039.protected preserve=yes
          mutable void * target;      // target ptr and type
          mutable TypeId target_tid;
          mutable bool writable;      // target writability
          mutable bool addressed;     // flag: & operator has been applied
          mutable HIID resid;         // residual id for initializing new fields
          mutable int  resindex;      // residual index for initializing new elements

          ConstHook();
          ConstHook( const NestableContainer &parent,const HIID &id );
          ConstHook( const NestableContainer &parent,int n );

          // This is called to get a value, for built-in scalar types only
          void get_scalar( void *data,TypeId tid,bool implicit=False ) const;

          // This is called to access by reference, for all types
          const void *get_address(TypeId tid,bool must_write,bool implicit=False,bool pointer=False ) const;

          // This is called to access by pointer, for all types
          const void *get_pointer(TypeId tid,bool must_write,bool implicit=False ) const;

          // helper function applies new id-index to hook
          const void *applyIndex (const HIID &id) const;

          // helper function applies new numeric index to hook
          const void *applyIndex (int n) const;
      
          //## end NestableContainer::ConstHook%3C614FDE0039.protected
      private:
        //## Constructors (generated)
          ConstHook(const ConstHook &right);

        //## Assignment Operation (generated)
          ConstHook & operator=(const ConstHook &right);

        // Additional Private Declarations
          //## begin NestableContainer::ConstHook%3C614FDE0039.private preserve=yes
          //## end NestableContainer::ConstHook%3C614FDE0039.private

      private: //## implementation
        // Additional Implementation Declarations
          //## begin NestableContainer::ConstHook%3C614FDE0039.implementation preserve=yes
          //## end NestableContainer::ConstHook%3C614FDE0039.implementation

    };

    //## begin NestableContainer::ConstHook%3C614FDE0039.postscript preserve=yes
    //## end NestableContainer::ConstHook%3C614FDE0039.postscript

    //## begin NestableContainer::Hook%3C62A13101C9.preface preserve=yes
    //## end NestableContainer::Hook%3C62A13101C9.preface

    //## Class: Hook%3C62A13101C9
    //## Category: PSCF::DMI%3BEAB1F2006B; Global
    //## Subsystem: DMI%3C10CC810155
    //## Persistence: Transient
    //## Cardinality/Multiplicity: n



    class Hook : public ConstHook  //## Inherits: <unnamed>%3C62A15F005C
    {
      //## begin NestableContainer::Hook%3C62A13101C9.initialDeclarations preserve=yes
      //## end NestableContainer::Hook%3C62A13101C9.initialDeclarations

      public:
        // Additional Public Declarations
          //## begin NestableContainer::Hook%3C62A13101C9.public preserve=yes
          friend NestableContainer;
          // pull non-in const accessdor methods
          #define ForceConstDefinitions 1
          #include "DataAcc-NonConst.h"

          // address-of operator   
          const Hook & operator & () const;

          // explicitly initializes underlying object, if necessary
          const Hook & init () const;

          // inserting an object
          BlockableObject & put ( BlockableObject &obj,int flags );
          const BlockableObject & put ( const BlockableObject &obj,int flags );

          // objref assignment -- assigns copy of ObjRef
          ObjRef & operator = ( const ObjRef &ref ) const;
          // objref assignment w/xfer 
          ObjRef & operator <<= ( ObjRef &ref ) const;
          // index-into operator [id]
          const Hook & operator [] (const HIID &id) const;
          const Hook & operator [] (const string &id) const 
                                   { return (*this)[HIID(id)]; } 
          const Hook & operator [] (const char *id) const
                                { return (*this)[HIID(id)]; } 
          // index-into operator [n]
          const Hook & operator [] (int n) const;
          bool exists () const;

          string sdebug ( int detail = 1,const string &prefix = "",const char *name = "Hook" ) const
          { return ConstHook::sdebug(detail,prefix,name); }
          const char *debug ( int detail = 1,const string &prefix = "",const char *name = "Hook" ) const
          { return Debug::staticBuffer(sdebug(detail,prefix,name)); }
          //## end NestableContainer::Hook%3C62A13101C9.public
      protected:
        // Additional Protected Declarations
          //## begin NestableContainer::Hook%3C62A13101C9.protected preserve=yes
          Hook( NestableContainer &parent,const HIID &id );
          Hook( NestableContainer &parent,int n );

          // This is called to assign a value, for scalar & binary types
          const void * put_scalar( const void *data,TypeId tid,size_t sz ) const;

          // This is called to allocate a new object in the container (index is >0)
          ObjRef * alloc_objref (TypeId tid) const;

          // Helper function to assign an object.  
          void assign_object( BlockableObject *obj,TypeId tid,int flags ) const;

          // const version forces a read-only ref
          void assign_object( const BlockableObject *obj,TypeId tid,int flags ) const;

          // Helper function assigns an objref     
          ObjRef & assign_objref ( const ObjRef &ref,int flags ) const;

          //## end NestableContainer::Hook%3C62A13101C9.protected
      private:
        //## Constructors (generated)
          Hook();

          Hook(const Hook &right);

        //## Assignment Operation (generated)
          Hook & operator=(const Hook &right);

        // Additional Private Declarations
          //## begin NestableContainer::Hook%3C62A13101C9.private preserve=yes
          //## end NestableContainer::Hook%3C62A13101C9.private

      private: //## implementation
        // Additional Implementation Declarations
          //## begin NestableContainer::Hook%3C62A13101C9.implementation preserve=yes
          //## end NestableContainer::Hook%3C62A13101C9.implementation

    };

    //## begin NestableContainer::Hook%3C62A13101C9.postscript preserve=yes
    //## end NestableContainer::Hook%3C62A13101C9.postscript


    //## Other Operations (specified)
      //## Operation: get%3C56A6C50088
      //	Abstract virtual function for dereferencing a container field
      //	indicated by id. Must be implemented by all child classes.
      //	This is the method called by the hook operator [](const HIID &).
      //	Returns a pointer to the field data, or 0 for no such field.  For
      //	dynamic types, this should be a pointer to an ObjRef, for all other
      //	types, a pointer to the data itself. Returns the type and writable
      //	property in 'tid' and 'can_write'. If must_write is True, should
      //	throw an exception if data is read-only. If check_tid is non-0,
      //	should throw exceptions on a type mismatch. The special case of Tp
      //	Numeric should be honored: when check_tid==TpNumeric, then throw
      //	exception only if type is not numeric. Can also throw exceptions if
      //	id is malformed (i.e. contains indices that are out of range, etc.)
      //	When called with a null HIID, this means the container is being
      //	accessed as a scalar. You can then throw an exception if the
      //	contents are not a scalar.
      //	See DataRecord and DataField for example implementations.
      virtual const void * get (const HIID &id, TypeId& tid, bool& can_write, TypeId check_tid = 0, bool must_write = False) const = 0;

      //## Operation: get%3C7A13C90269
      //	Version of get() for an integer field specification. Default
      //	implementation  converts n into a single-index HIID.
      virtual const void * get (int n, TypeId& tid, bool& can_write, TypeId check_tid = 0, bool must_write = False) const;

      //## Operation: insert%3C7A13D703AA
      //	Abstract virtual method for allocating a new field in a container.
      //	Must be implemented by all child classes.
      //	Tid is the type of object to allocate (can throw exception if this
      //	is not legal, e.g., if the container expects homogenous types or
      //	something).
      //	The actual type allocated is returned in real_tid, this may be !=
      //	tid if both types are built-in numerics.
      //	Returns pointer to new data, or pointer to an unattached ObjRef, in
      //	the case of dynamic types.
      virtual void * insert (const HIID &id, TypeId tid, TypeId &real_tid) = 0;

      //## Operation: insert%3C7A140A003C
      //	Version of insert() for a numeric index. Default implementation
      //	simply maps to the standard insert() with a single-index HIID.
      virtual void * insert (int n, TypeId tid, TypeId &real_tid);

      //## Operation: size%3C7A154E01AB
      //	Abstract virtual function. Should returns size of container.
      virtual int size () const = 0;

      //## Operation: type%3C7A1552012E
      //	Abstract virtual function. Should return TypeId of contents. If
      //	container is not type-homogenous, just return NullType.
      virtual TypeId type () const = 0;

      //## Operation: get%3C5FA32402A9
      //	Version of get() with type and access check only. Used by the get
      //	Field() and getFieldWr() macros.
      const void * get (const HIID &id, TypeId check_tid) const;

      //## Operation: getWr%3C5FB39A027F
      void * getWr (const HIID &id, TypeId check_tid);

      //## Operation: getFieldInfo%3BE9828D0266
      //	Universal function to request all  info about a field. Returns False
      //	if no such field. By default, implemented in terms of get(), but
      //	child classes can overload it for efficiency.
      //	Set no_throw to True to disable all exceptions (and return False
      //	instead).
      //	fieldType() and hasField() are implemented in terms of this method.
      virtual bool getFieldInfo (const HIID &id, TypeId &tid, bool& can_write, bool no_throw = False) const;

      //## Operation: hasField%3C56AC2902A1
      //	Returns true if field exists, false if not. Does not throw
      //	exceptions.
      virtual bool hasField (const HIID &id) const;

      //## Operation: fieldType%3C5958C203A0
      //	Returns type of field, or 0 if no such field. Does not throw
      //	exceptions (returns 0 instead).
      virtual TypeId fieldType (const HIID &id) const;

      //## Operation: select%3BE982760231
      virtual bool select (const HIIDSet &id) = 0;

      //## Operation: clearSelection%3BFBDC0D025A
      virtual void clearSelection () = 0;

      //## Operation: selectionToBlock%3BFBDC1D028F
      virtual int selectionToBlock (BlockSet& set) = 0;

      //## Operation: isNestable%3BFCD8180044
      bool isNestable ();

      //## Operation: isNestable%3C5551E201AE
      //	Static function, checks if a type is a nestable (or a subclass
      //	thereof).
      static bool isNestable (TypeId tid);

  public:
    // Additional Public Declarations
      //## begin NestableContainer%3BE97CE100AF.public preserve=yes
      ConstHook operator [] (const HIID &id) const  { return ConstHook(*this,id); }
      ConstHook operator [] (int index) const       { return ConstHook(*this,index); }
      Hook operator [] (const HIID &id)             { return Hook(*this,id); }
      Hook operator [] (int index)                  { return Hook(*this,index); }
      //## end NestableContainer%3BE97CE100AF.public
  protected:
    // Additional Protected Declarations
      //## begin NestableContainer%3BE97CE100AF.protected preserve=yes
      //## end NestableContainer%3BE97CE100AF.protected

  private:
    // Additional Private Declarations
      //## begin NestableContainer%3BE97CE100AF.private preserve=yes
      DeclareRegistry(NestableContainer,int,bool);
      //## end NestableContainer%3BE97CE100AF.private
  private: //## implementation
    // Additional Implementation Declarations
      //## begin NestableContainer%3BE97CE100AF.implementation preserve=yes
      //## end NestableContainer%3BE97CE100AF.implementation

};

//## begin NestableContainer%3BE97CE100AF.postscript preserve=yes
//## end NestableContainer%3BE97CE100AF.postscript

// Class NestableContainer::ConstHook 

// Class NestableContainer::Hook 

// Class NestableContainer 


//## Other Operations (inline)
inline const void * NestableContainer::get (int n, TypeId& tid, bool& can_write, TypeId check_tid, bool must_write) const
{
  //## begin NestableContainer::get%3C7A13C90269.body preserve=yes
  return get(HIID(n),tid,can_write,check_tid,must_write);
  //## end NestableContainer::get%3C7A13C90269.body
}

inline void * NestableContainer::insert (int n, TypeId tid, TypeId &real_tid)
{
  //## begin NestableContainer::insert%3C7A140A003C.body preserve=yes
  return insert(HIID(n),tid,real_tid);
  //## end NestableContainer::insert%3C7A140A003C.body
}

inline const void * NestableContainer::get (const HIID &id, TypeId check_tid) const
{
  //## begin NestableContainer::get%3C5FA32402A9.body preserve=yes
  TypeId dum1; bool dum2;
  return get(id,dum1,dum2,check_tid,False);
  //## end NestableContainer::get%3C5FA32402A9.body
}

inline void * NestableContainer::getWr (const HIID &id, TypeId check_tid)
{
  //## begin NestableContainer::getWr%3C5FB39A027F.body preserve=yes
  TypeId dum1; bool dum2;
  return (void*)get(id,dum1,dum2,check_tid,True);
  //## end NestableContainer::getWr%3C5FB39A027F.body
}

inline bool NestableContainer::isNestable ()
{
  //## begin NestableContainer::isNestable%3BFCD8180044.body preserve=yes
  //## end NestableContainer::isNestable%3BFCD8180044.body

  return True;

}

inline bool NestableContainer::isNestable (TypeId tid)
{
  //## begin NestableContainer::isNestable%3C5551E201AE.body preserve=yes
  return registry.find(tid);
  //## end NestableContainer::isNestable%3C5551E201AE.body
}

//## begin module%3C10CC830067.epilog preserve=yes
inline NestableContainer::ConstHook::ConstHook()
    : addressed(False),resindex(-1)
{
}

inline NestableContainer::ConstHook::ConstHook( const NestableContainer &parent,const HIID &id )
    : target(const_cast<NestableContainer *>(&parent)),addressed(False),resindex(-1)
{
  target_tid = parent.objectType();
  (*this)[id];
}

inline NestableContainer::ConstHook::ConstHook( const NestableContainer &parent,int n )
    : target(const_cast<NestableContainer *>(&parent)),addressed(False),resindex(-1)
{
  target_tid = parent.objectType();
  (*this)[n];
}

// This is called to access by pointer, for all types
inline const void * NestableContainer::ConstHook::get_pointer(TypeId tid,bool must_write,bool implicit ) const
{
  FailWhen(!addressed && implicit,"missing '&' operator");
  return get_address(tid,must_write,implicit,True);
}

// helper function applies new id-index to hook
inline const void * NestableContainer::ConstHook::applyIndex (const HIID &id) const
{
  const NestableContainer *nc = NestableContainer::isNestable(target_tid) ?
      static_cast<NestableContainer *>(target) : 0;
  FailWhen(!nc,"can't index into "+target_tid.toString()+": not a container");
  // index into container for new target
  return nc->get(id,target_tid,writable,0,False);
}

// helper function applies new numeric index to hook
inline const void * NestableContainer::ConstHook::applyIndex (int n) const
{
  const NestableContainer *nc = NestableContainer::isNestable(target_tid) ?
      static_cast<NestableContainer *>(target) : 0;
  FailWhen(!nc,"can't index into "+target_tid.toString()+": not a container");
  // index into container for new target
  return nc->get(n,target_tid,writable,0,False);
}

// address-of operator   
inline const NestableContainer::ConstHook & NestableContainer::ConstHook::operator & () const
{
  FailWhen(addressed,"unexpected second '&' operator");
  addressed = True;
  return *this;
}
inline const NestableContainer::ConstHook & NestableContainer::ConstHook::operator [] (const HIID &id) const
{
  FailWhen(addressed,"unexpected '&' operator");
  int sep = id.findFirstSlash();
  if( !sep )
    return (*this)[id.subId(1)];
  else if( sep == (int)(id.size()-1) )
    return (*this)[id.subId(0,id.size()-1)];
  else if( sep > 0 )
    return (*this)[id.subId(0,sep-1)][id.subId(sep+1)];
  const void *newtarget = applyIndex(id);
  FailWhen(!newtarget,"["+id.toString()+"] does not refer to a valid field");
  target = const_cast<void*>(newtarget);
  return *this;
}

inline const NestableContainer::ConstHook & NestableContainer::ConstHook::operator [] (int n) const
{
  FailWhen(addressed,"unexpected '&' operator");
  const void *newtarget = applyIndex(n);
  FailWhen(!newtarget,Debug::ssprintf("[%d] does not refer to a valid field",n));
  target = const_cast<void*>(newtarget);
  return *this;
}

inline TypeId NestableContainer::ConstHook::type () const
{
  return target_tid;
}

inline NestableContainer::Hook::Hook( NestableContainer &parent,const HIID &id )
    : ConstHook()
{
  target = const_cast<NestableContainer*>(&parent);
  target_tid = parent.objectType();
  (*this)[id];
}

inline NestableContainer::Hook::Hook( NestableContainer &parent,int n )
    : ConstHook()
{
  target = const_cast<NestableContainer*>(&parent);
  target_tid = parent.objectType();
  (*this)[n];
}

// const version forces a read-only ref
inline void NestableContainer::Hook::assign_object( const BlockableObject *obj,TypeId tid,int flags ) const
{
  // cast away const but that's OK since we force r/o ref  
  return assign_object(const_cast<BlockableObject*>(obj),tid,(flags&~DMI::WRITE)|DMI::READONLY);
}

// address-of operator   
inline const NestableContainer::Hook & NestableContainer::Hook::operator & () const
{
  FailWhen(addressed,"unexpected second '&' operator");
  addressed = True;
  return *this;
}

inline BlockableObject & NestableContainer::Hook::put ( BlockableObject &obj,int flags )
{
  assign_object(&obj,obj.objectType(),flags);
  return obj;
}

inline const BlockableObject & NestableContainer::Hook::put ( const BlockableObject &obj,int flags )
{
  assign_object(&obj,obj.objectType(),flags);
  return obj;
}

// objref assignment -- assigns copy of ObjRef
inline ObjRef & NestableContainer::Hook::operator = ( const ObjRef &ref ) const
{
  return assign_objref(ref,DMI::PRESERVE_RW|DMI::COPYREF);
}
// objref assignment w/xfer 
inline ObjRef & NestableContainer::Hook::operator <<= ( ObjRef &ref ) const
{
  return assign_objref(ref,DMI::PRESERVE_RW);
}
// index-into operator [id]
inline const NestableContainer::Hook & NestableContainer::Hook::operator [] (const HIID &id) const
{
  FailWhen(addressed,"unexpected '&' operator");
  FailWhen(resid.size(),"uninitialized element ["+resid.toString()+"]"); 
  FailWhen(resindex>=0,ssprintf("uninitialized element [%d]",resindex)); 
  int sep = id.findFirstSlash();
  if( !sep )
    return (*this)[id.subId(1)];
  else if( sep == (int)id.size()-1 )
    return (*this)[id.subId(0,-2)];
  else if( sep > 0 )
    return (*this)[id.subId(0,sep-1)][id.subId(sep+1,-1)];
  const void *newtarget = applyIndex(id);
  if( newtarget )
    target = const_cast<void*>(newtarget);
  else
    resid = id;
  return *this;
}

// index-into operator [n]
inline const NestableContainer::Hook & NestableContainer::Hook::operator [] (int n)  const
{
  FailWhen(addressed,"unexpected '&' operator");
  FailWhen(resid.size(),"uninitialized element ["+resid.toString()+"]"); 
  FailWhen(resindex>=0,ssprintf("uninitialized element [%d]",resindex)); 
  const void *newtarget = applyIndex(n);
  if( newtarget )
    target = const_cast<void*>(newtarget);
  else
    resindex = n;
  return *this;
}

inline bool NestableContainer::Hook::exists () const
{
  return !resid.size() && resindex<0;
}

//## end module%3C10CC830067.epilog


#endif
