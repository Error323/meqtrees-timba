//## begin module%1.4%.codegen_version preserve=yes
//   Read the documentation to learn more about C++ code generator
//   versioning.
//## end module%1.4%.codegen_version

//## begin module%3C10CC830067.cm preserve=no
//	  %X% %Q% %Z% %W%
//## end module%3C10CC830067.cm

//## begin module%3C10CC830067.cp preserve=no
//## end module%3C10CC830067.cp

//## Module: NestableContainer%3C10CC830067; Package specification
//## Subsystem: DMI%3C10CC810155
//	f:\lofar\dvl\lofar\cep\cpa\pscf\src
//## Source file: f:\lofar8\oms\LOFAR\cep\cpa\pscf\src\NestableContainer.h

#ifndef NestableContainer_h
#define NestableContainer_h 1

//## begin module%3C10CC830067.additionalIncludes preserve=no
#include "Common.h"
#include "DMI.h"
//## end module%3C10CC830067.additionalIncludes

//## begin module%3C10CC830067.includes preserve=yes
#include "TypeInfo.h"
#include "TID-PSCF.h"
#include "pscf/Timestamp.h"
//## end module%3C10CC830067.includes

// Registry
#include "Registry.h"
// HIIDSet
#include "HIIDSet.h"
// BlockableObject
#include "BlockableObject.h"
//## begin module%3C10CC830067.declarations preserve=no
//## end module%3C10CC830067.declarations

//## begin module%3C10CC830067.additionalDeclarations preserve=yes
using Debug::ssprintf;
//## end module%3C10CC830067.additionalDeclarations


//## begin NestableContainer%3BE97CE100AF.preface preserve=yes
class NestableContainer;
//## end NestableContainer%3BE97CE100AF.preface

//## Class: NestableContainer%3BE97CE100AF; Abstract
//	This is an abstract base class for data containers. It implements
//	hooks (see Hook and ConstHook below) that allow access to elements
//	of the container via the [HIID] and [int] operators.
//
//	To derive a specific container that will be compatible with hooks
//	(and thus can be accessed via []), you need to  implement four
//	virtual methods: get(HIID,...), insert(HIID,...), size(), type().
//	See below for specifics.
//
//	You can optionally implement get(int,...), insert(int...), if
//	accessing via a numeric index is a special case for your container.
//	Also, isContiguous() should be redefined to return True, if your
//	container stores data in a contigouus block of memory.
//## Category: PSCF::DMI%3BEAB1F2006B; Global
//## Subsystem: DMI%3C10CC810155
//## Persistence: Transient
//## Cardinality/Multiplicity: n



//## Uses: <unnamed>%3BFBAF8303C0;HIIDSet { -> }
//## Uses: <unnamed>%3C5A7A4400BF;UniRegistry { -> }

class NestableContainer : public BlockableObject  //## Inherits: <unnamed>%3BFCD87C0106
{
  //## begin NestableContainer%3BE97CE100AF.initialDeclarations preserve=yes
  //## end NestableContainer%3BE97CE100AF.initialDeclarations

  public:
    //## begin NestableContainer::ConstHook%3C614FDE0039.preface preserve=yes
    class ConstHook;
    class Hook;
    //## end NestableContainer::ConstHook%3C614FDE0039.preface

    //## Class: ConstHook%3C614FDE0039
    //	ConstHook/Hook are helper classes generated by the [id] and  [n]
    //	operators. Hooks implements assignment and conversion operators for
    //	data elements.
    //## Category: PSCF::DMI%3BEAB1F2006B; Global
    //## Subsystem: DMI%3C10CC810155
    //## Persistence: Transient
    //## Cardinality/Multiplicity: n



    class ConstHook 
    {
      //## begin NestableContainer::ConstHook%3C614FDE0039.initialDeclarations preserve=yes
      //## end NestableContainer::ConstHook%3C614FDE0039.initialDeclarations

      public:
        // Additional Public Declarations
          //## begin NestableContainer::ConstHook%3C614FDE0039.public preserve=yes
          friend NestableContainer;
      
          // pull in const accessdor methods
          #include "DataAcc-Const.h"

          // address-of operator   
          const ConstHook & operator & () const;
          
          // subscript operators
          const ConstHook & operator [] (const HIID &id) const;
          const ConstHook & operator [] (const string &id) const 
                            { return (*this)[HIID(id)]; } 
          const ConstHook & operator [] (const char *id) const
                            { return (*this)[HIID(id)]; } 
          const ConstHook & operator [] (int n) const;

          // privatizes target, if it is a dynamic object
          Hook privatize (int flags = 0) const;
          
          // type of data being referred to (if referring to a container,
          // returns type of contents)
          TypeId type () const;

          // returns True if referring to a container
          bool isContainer () const;
          
          // actual object being referred to (i.e. doesn't look into containers)
          TypeId actualType () const;
          
          // size information
          int size () const;
          
          // standard debug info
          string sdebug ( int detail = 1,const string &prefix = "",const char *name = "cHook" ) const;
          const char *debug ( int detail = 1,const string &prefix = "",const char *name = "cHook" ) const
          { return Debug::staticBuffer(sdebug(detail,prefix,name)); }

          //## end NestableContainer::ConstHook%3C614FDE0039.public
      protected:
        // Additional Protected Declarations
          //## begin NestableContainer::ConstHook%3C614FDE0039.protected preserve=yes
          mutable void * target;      // target ptr and type
          mutable TypeId target_tid;
          mutable bool writable;      // target writability
          mutable bool addressed;     // flag: & operator has been applied
          mutable HIID resid;         // residual id for initializing new fields
          mutable int  resindex;      // residual index for initializing new elements

          ConstHook();
          ConstHook( const NestableContainer &parent,const HIID &id );
          ConstHook( const NestableContainer &parent,int n );
          
          // if target is an NC, returns pointer to it, else 0
          const NestableContainer * asNestable() const;
          NestableContainer * asNestableWr() const;

          // This is called to get a value, for built-in scalar types only
          void get_scalar( void *data,TypeId tid,bool implicit=False ) const;

          // This is called to access by reference, for all types
          const void *get_address(TypeId tid,bool must_write,bool implicit=False,bool pointer=False ) const;

          // This is called to access by pointer, for all types
          const void *get_pointer(TypeId tid,bool must_write,bool implicit=False ) const;

          // helper function applies new id-index to hook
          const void *applyIndex (const HIID &id) const;

          // helper function applies new numeric index to hook
          const void *applyIndex (int n) const;
      
          //## end NestableContainer::ConstHook%3C614FDE0039.protected
      private:
        //## Assignment Operation (generated)
          ConstHook & operator=(const ConstHook &right);

        // Additional Private Declarations
          //## begin NestableContainer::ConstHook%3C614FDE0039.private preserve=yes
          //## end NestableContainer::ConstHook%3C614FDE0039.private

      private: //## implementation
        // Additional Implementation Declarations
          //## begin NestableContainer::ConstHook%3C614FDE0039.implementation preserve=yes
          //## end NestableContainer::ConstHook%3C614FDE0039.implementation

    };

    //## begin NestableContainer::ConstHook%3C614FDE0039.postscript preserve=yes
    //## end NestableContainer::ConstHook%3C614FDE0039.postscript

    //## begin NestableContainer::Hook%3C62A13101C9.preface preserve=yes
    //## end NestableContainer::Hook%3C62A13101C9.preface

    //## Class: Hook%3C62A13101C9
    //## Category: PSCF::DMI%3BEAB1F2006B; Global
    //## Subsystem: DMI%3C10CC810155
    //## Persistence: Transient
    //## Cardinality/Multiplicity: n



    class Hook : public ConstHook  //## Inherits: <unnamed>%3C62A15F005C
    {
      //## begin NestableContainer::Hook%3C62A13101C9.initialDeclarations preserve=yes
      //## end NestableContainer::Hook%3C62A13101C9.initialDeclarations

      public:
        // Additional Public Declarations
          //## begin NestableContainer::Hook%3C62A13101C9.public preserve=yes
          friend NestableContainer;
          friend ConstHook;
          // pull non-in const accessdor methods
          #define ForceConstDefinitions 1
          #include "DataAcc-NonConst.h"

          // address-of operator   
          const Hook & operator & () const;

          // explicitly initializes underlying object, if necessary
          const Hook & init () const;

          // inserting an object
          BlockableObject & put ( BlockableObject &obj,int flags );
          const BlockableObject & put ( const BlockableObject &obj,int flags );

          // objref assignment -- assigns copy of ObjRef
          ObjRef & operator = ( const ObjRef &ref ) const;
          // objref assignment w/xfer 
          ObjRef & operator <<= ( ObjRef &ref ) const;
          // index-into operator [id]
          const Hook & operator [] (const HIID &id) const;
          const Hook & operator [] (const string &id) const 
                                   { return (*this)[HIID(id)]; } 
          const Hook & operator [] (const char *id) const
                                { return (*this)[HIID(id)]; } 
          // index-into operator [n]
          const Hook & operator [] (int n) const;
          
          // privatizes target, if it is a dynamic object
          const Hook & privatize (int flags = 0) const;
          
          // does target exist (or is it a new one?)
          bool exists () const;

          string sdebug ( int detail = 1,const string &prefix = "",const char *name = "Hook" ) const
          { return ConstHook::sdebug(detail,prefix,name); }
          const char *debug ( int detail = 1,const string &prefix = "",const char *name = "Hook" ) const
          { return Debug::staticBuffer(sdebug(detail,prefix,name)); }
          //## end NestableContainer::Hook%3C62A13101C9.public
      protected:
        // Additional Protected Declarations
          //## begin NestableContainer::Hook%3C62A13101C9.protected preserve=yes
          Hook( NestableContainer &parent,const HIID &id );
          Hook( NestableContainer &parent,int n );
          Hook( const void *targ,TypeId tid,bool write );

          // This is called to assign a value, for scalar & binary types
          const void * put_scalar( const void *data,TypeId tid,size_t sz ) const;

          // This is called to allocate a new object in the container (index is >0)
          ObjRef * alloc_objref (TypeId tid) const;

          // Helper function to assign an object.  
          void assign_object( BlockableObject *obj,TypeId tid,int flags ) const;

          // const version forces a read-only ref
          void assign_object( const BlockableObject *obj,TypeId tid,int flags ) const;

          // Helper function assigns an objref     
          ObjRef & assign_objref ( const ObjRef &ref,int flags ) const;

          //## end NestableContainer::Hook%3C62A13101C9.protected
      private:
        //## Constructors (generated)
          Hook();

        //## Assignment Operation (generated)
          Hook & operator=(const Hook &right);

        // Additional Private Declarations
          //## begin NestableContainer::Hook%3C62A13101C9.private preserve=yes
          //## end NestableContainer::Hook%3C62A13101C9.private

      private: //## implementation
        // Additional Implementation Declarations
          //## begin NestableContainer::Hook%3C62A13101C9.implementation preserve=yes
          //## end NestableContainer::Hook%3C62A13101C9.implementation

    };

    //## begin NestableContainer::Hook%3C62A13101C9.postscript preserve=yes
    //## end NestableContainer::Hook%3C62A13101C9.postscript

    //## Constructors (specified)
      //## Operation: NestableContainer%3C7F928D00C0
      NestableContainer (bool write = True);


    //## Other Operations (specified)
      //## Operation: get%3C56A6C50088
      //	get(HIID): Abstract virtual function for dereferencing a container
      //	element indicated by id. Must be implemented by all child classes.
      //	This is the method called by the hook operator [](const HIID &). See
      //	DataRecord and DataField for example implementations.
      //	The return value is a pointer to the data element (or to an ObjRef
      //	to the data, see below). A return value of 0 indicates that the
      //	element doesn't exist but can be inserted (e.g. no such field in
      //	record). An exception may be thrown otherwise (e.g. array inndex out
      //	of range).
      virtual const void * get (const HIID &id, 	// Specifies an element
      	// in the container. A null HIID (id.size()==0) implies the first
      	// element.
      TypeId& tid, 	// Return the actual type of the element here.
      bool& can_write, 	// Return True if the datum is writable, False if not.
      TypeId check_tid = 0, 	// This is the type being requested.
      	// An exception should be thrown if there's a mismatch with the
      	// contents type. The following special cases must be handled:
      	// TpNumeric: any built-in numeric type is expected.
      	// TpObjRef: a dynamic type is expected, return pointer to ObjRef, and
      	// set tid=TpObjRef.
      	// TpObject: a dynamic type is expected, return pointer to actual
      	// object rather than the ref.
      	// 0: no type checking. For dynamic types, returning an ObjRef is
      	// preferred.
      bool must_write = False	// If True and datum is read-only, throw an exception
      ) const = 0;

      //## Operation: get%3C7A13C90269
      //	get(int): this is a version of get() with a numeric element
      //	specification. This is the method called by the hook operator
      //	[](int). The default implementation simply converts the index into a
      //	single-index HIID, and calls get(HIID).
      virtual const void * get (int n, TypeId& tid, bool& can_write, TypeId check_tid = 0, bool must_write = False) const;

      //## Operation: insert%3C7A13D703AA
      //	Abstract virtual method for allocating a new field in a container.
      //	Must be implemented by all child classes.
      //	Tid is the type of object to allocate (can throw exception if this
      //	is not legal, e.g., if the container expects homogenous types or
      //	something).
      //	The actual type allocated is returned in real_tid, this may be !=
      //	tid if both types are built-in numerics.
      //	Returns pointer to new data, or pointer to an unattached ObjRef, in
      //	the case of dynamic types.
      virtual void * insert (const HIID &id, TypeId tid, TypeId &real_tid) = 0;

      //## Operation: insert%3C7A140A003C
      //	Version of insert() for a numeric index. Default implementation
      //	simply maps to the standard insert() with a single-index HIID.
      virtual void * insert (int n, TypeId tid, TypeId &real_tid);

      //## Operation: size%3C7A154E01AB
      //	Abstract virtual function. Returns the number of elements in the
      //	container.
      virtual int size () const = 0;

      //## Operation: type%3C7A1552012E
      //	Abstract virtual function. Should return the type of the contents.
      //	If contents are not of a homogenous type (e.g. a record), just
      //	return NullType.
      virtual TypeId type () const = 0;

      //## Operation: isContiguous%3C7F97CB00F6
      //	ReturnsTrue if storage of container is contiguous (i.e., if data[n]
      //	is located at (&data[0])+n). Default implementation returns False.
      virtual bool isContiguous () const;

      //## Operation: get%3C5FA32402A9
      //	Version of get() with type and access check only. Used by the get
      //	Field() and getFieldWr() macros.
      const void * get (const HIID &id, TypeId check_tid) const;

      //## Operation: getWr%3C5FB39A027F
      void * getWr (const HIID &id, TypeId check_tid);

      //## Operation: getFieldInfo%3BE9828D0266
      //	Universal function to request all  info about a field. Returns False
      //	if no such field. By default, implemented in terms of get(), but
      //	child classes can overload it for efficiency.
      //	Set no_throw to True to disable all exceptions (and return False
      //	instead).
      //	fieldType() and hasField() are implemented in terms of this method.
      virtual bool getFieldInfo (const HIID &id, TypeId &tid, bool& can_write, bool no_throw = False) const;

      //## Operation: hasField%3C56AC2902A1
      //	Returns true if field exists, false if not. Does not throw
      //	exceptions.
      virtual bool hasField (const HIID &id) const;

      //## Operation: fieldType%3C5958C203A0
      //	Returns type of field, or 0 if no such field. Does not throw
      //	exceptions (returns 0 instead).
      virtual TypeId fieldType (const HIID &id) const;

      //## Operation: select%3BE982760231
      virtual bool select (const HIIDSet &id) = 0;

      //## Operation: clearSelection%3BFBDC0D025A
      virtual void clearSelection () = 0;

      //## Operation: selectionToBlock%3BFBDC1D028F
      virtual int selectionToBlock (BlockSet& set) = 0;

      //## Operation: isNestable%3BFCD8180044
      bool isNestable () const;

      //## Operation: isNestable%3C5551E201AE
      //	Static function, checks if a type is a nestable (or a subclass
      //	thereof).
      static bool isNestable (TypeId tid);

    //## Get and Set Operations for Class Attributes (generated)

      //## Attribute: writable%3C7F924300A6
      bool isWritable () const;

  public:
    // Additional Public Declarations
      //## begin NestableContainer%3BE97CE100AF.public preserve=yes
      ConstHook operator [] (const HIID &id) const  { return ConstHook(*this,id); }
      ConstHook operator [] (int index) const       { return ConstHook(*this,index); }
      Hook operator [] (const HIID &id)             { return Hook(*this,id); }
      Hook operator [] (int index)                  { return Hook(*this,index); }
      //## end NestableContainer%3BE97CE100AF.public
  protected:
    // Data Members for Class Attributes

      //## begin NestableContainer::writable%3C7F924300A6.attr preserve=no  public: bool {U} 
      bool writable;
      //## end NestableContainer::writable%3C7F924300A6.attr

    // Additional Protected Declarations
      //## begin NestableContainer%3BE97CE100AF.protected preserve=yes
      //## end NestableContainer%3BE97CE100AF.protected

  private:
    // Additional Private Declarations
      //## begin NestableContainer%3BE97CE100AF.private preserve=yes
      DeclareRegistry(NestableContainer,int,bool);
      //## end NestableContainer%3BE97CE100AF.private
  private: //## implementation
    // Additional Implementation Declarations
      //## begin NestableContainer%3BE97CE100AF.implementation preserve=yes
      //## end NestableContainer%3BE97CE100AF.implementation

};

//## begin NestableContainer%3BE97CE100AF.postscript preserve=yes
//## end NestableContainer%3BE97CE100AF.postscript

// Class NestableContainer::ConstHook 

// Class NestableContainer::Hook 

// Class NestableContainer 

inline NestableContainer::NestableContainer (bool write)
  //## begin NestableContainer::NestableContainer%3C7F928D00C0.hasinit preserve=no
  //## end NestableContainer::NestableContainer%3C7F928D00C0.hasinit
  //## begin NestableContainer::NestableContainer%3C7F928D00C0.initialization preserve=yes
  : writable(write)
  //## end NestableContainer::NestableContainer%3C7F928D00C0.initialization
{
  //## begin NestableContainer::NestableContainer%3C7F928D00C0.body preserve=yes
  //## end NestableContainer::NestableContainer%3C7F928D00C0.body
}



//## Other Operations (inline)
inline const void * NestableContainer::get (int n, TypeId& tid, bool& can_write, TypeId check_tid, bool must_write) const
{
  //## begin NestableContainer::get%3C7A13C90269.body preserve=yes
  return get(HIID(n),tid,can_write,check_tid,must_write);
  //## end NestableContainer::get%3C7A13C90269.body
}

inline void * NestableContainer::insert (int n, TypeId tid, TypeId &real_tid)
{
  //## begin NestableContainer::insert%3C7A140A003C.body preserve=yes
  return insert(HIID(n),tid,real_tid);
  //## end NestableContainer::insert%3C7A140A003C.body
}

inline bool NestableContainer::isContiguous () const
{
  //## begin NestableContainer::isContiguous%3C7F97CB00F6.body preserve=yes
  return False;
  //## end NestableContainer::isContiguous%3C7F97CB00F6.body
}

inline const void * NestableContainer::get (const HIID &id, TypeId check_tid) const
{
  //## begin NestableContainer::get%3C5FA32402A9.body preserve=yes
  TypeId dum1; bool dum2;
  return get(id,dum1,dum2,check_tid,False);
  //## end NestableContainer::get%3C5FA32402A9.body
}

inline void * NestableContainer::getWr (const HIID &id, TypeId check_tid)
{
  //## begin NestableContainer::getWr%3C5FB39A027F.body preserve=yes
  TypeId dum1; bool dum2;
  return (void*)get(id,dum1,dum2,check_tid,True);
  //## end NestableContainer::getWr%3C5FB39A027F.body
}

inline bool NestableContainer::isNestable () const
{
  //## begin NestableContainer::isNestable%3BFCD8180044.body preserve=yes
  //## end NestableContainer::isNestable%3BFCD8180044.body

  return True;

}

inline bool NestableContainer::isNestable (TypeId tid)
{
  //## begin NestableContainer::isNestable%3C5551E201AE.body preserve=yes
  return registry.find(tid);
  //## end NestableContainer::isNestable%3C5551E201AE.body
}

//## Get and Set Operations for Class Attributes (inline)

inline bool NestableContainer::isWritable () const
{
  //## begin NestableContainer::isWritable%3C7F924300A6.get preserve=no
  return writable;
  //## end NestableContainer::isWritable%3C7F924300A6.get
}

//## begin module%3C10CC830067.epilog preserve=yes
inline NestableContainer::ConstHook::ConstHook()
    : addressed(False),resindex(-1)
{
}

inline NestableContainer::ConstHook::ConstHook( const NestableContainer &parent,const HIID &id )
    : target(const_cast<NestableContainer *>(&parent)),addressed(False),resindex(-1)
{
  target_tid = parent.objectType();
  (*this)[id];
}

inline NestableContainer::ConstHook::ConstHook( const NestableContainer &parent,int n )
    : target(const_cast<NestableContainer *>(&parent)),addressed(False),resindex(-1)
{
  target_tid = parent.objectType();
  (*this)[n];
}

inline const NestableContainer * NestableContainer::ConstHook::asNestable () const
{
  TypeId tid = target_tid;
  const void *targ = target;
  if( tid == TpObjRef )
  {
    targ = &static_cast<ObjRef*>(target)->deref();
    tid = static_cast<const BlockableObject*>(targ)->objectType();
  }
  return NestableContainer::isNestable(tid) 
    ? static_cast<const NestableContainer*>(targ) 
    : 0;
}

inline NestableContainer * NestableContainer::ConstHook::asNestableWr () const
{
  TypeId tid = target_tid;
  void *targ = target;
  if( tid == TpObjRef )
  {
    targ = &static_cast<ObjRef*>(target)->dewr();
    tid = static_cast<BlockableObject*>(targ)->objectType();
  }
  return NestableContainer::isNestable(tid) 
    ? static_cast<NestableContainer*>(targ) 
    : 0;
}

// This is called to access by pointer, for all types
inline const void * NestableContainer::ConstHook::get_pointer(TypeId tid,bool must_write,bool implicit ) const
{
  FailWhen(!addressed && implicit,"missing '&' operator");
  return get_address(tid,must_write,implicit,True);
}

// helper function applies new id-index to hook
inline const void * NestableContainer::ConstHook::applyIndex (const HIID &id) const
{
  const NestableContainer *nc = asNestable();
  FailWhen(!nc,"can't index into "+target_tid.toString()+": not a container");
  // index into container for new target
  return nc->get(id,target_tid,writable,0,False);
}

// helper function applies new numeric index to hook
inline const void * NestableContainer::ConstHook::applyIndex (int n) const
{
  const NestableContainer *nc = asNestable();
  FailWhen(!nc,"can't index into "+target_tid.toString()+": not a container");
  // index into container for new target
  return nc->get(n,target_tid,writable,0,False);
}

// address-of operator   
inline const NestableContainer::ConstHook & NestableContainer::ConstHook::operator & () const
{
  FailWhen(addressed,"unexpected second '&' operator");
  addressed = True;
  return *this;
}
inline const NestableContainer::ConstHook & NestableContainer::ConstHook::operator [] (const HIID &id) const
{
  FailWhen(addressed,"unexpected '&' operator");
  int sep = id.findFirstSlash();
  if( !sep )
    return (*this)[id.subId(1)];
  else if( sep == (int)(id.size()-1) )
    return (*this)[id.subId(0,id.size()-1)];
  else if( sep > 0 )
    return (*this)[id.subId(0,sep-1)][id.subId(sep+1)];
  const void *newtarget = applyIndex(id);
  FailWhen(!newtarget,"["+id.toString()+"] does not refer to a valid field");
  target = const_cast<void*>(newtarget);
  return *this;
}

inline const NestableContainer::ConstHook & NestableContainer::ConstHook::operator [] (int n) const
{
  FailWhen(addressed,"unexpected '&' operator");
  const void *newtarget = applyIndex(n);
  FailWhen(!newtarget,Debug::ssprintf("[%d] does not refer to a valid field",n));
  target = const_cast<void*>(newtarget);
  return *this;
}

inline TypeId NestableContainer::ConstHook::actualType () const
{
  return target_tid;
}

inline bool NestableContainer::ConstHook::isContainer () const
{
  return asNestable() != 0;
}

inline TypeId NestableContainer::ConstHook::type () const
{
  const NestableContainer *nc = asNestable();
  return nc ? nc->type() : target_tid;
}

inline int NestableContainer::ConstHook::size () const
{
  const NestableContainer *nc = asNestable();
  return nc ? nc->size() : 1;
}

inline NestableContainer::Hook::Hook( NestableContainer &parent,const HIID &id )
    : ConstHook()
{
  target = const_cast<NestableContainer*>(&parent);
  target_tid = parent.objectType();
  writable = parent.isWritable();
  (*this)[id];
}

inline NestableContainer::Hook::Hook( NestableContainer &parent,int n )
    : ConstHook()
{
  target = const_cast<NestableContainer*>(&parent);
  target_tid = parent.objectType();
  (*this)[n];
}

inline NestableContainer::Hook::Hook( const void *targ,TypeId tid,bool write )
    : ConstHook()
{
  target = const_cast<void*>(targ); target_tid = tid; writable = write;
}

// const version forces a read-only ref
inline void NestableContainer::Hook::assign_object( const BlockableObject *obj,TypeId tid,int flags ) const
{
  // cast away const but that's OK since we force r/o ref  
  return assign_object(const_cast<BlockableObject*>(obj),tid,(flags&~DMI::WRITE)|DMI::READONLY);
}

// address-of operator   
inline const NestableContainer::Hook & NestableContainer::Hook::operator & () const
{
  FailWhen(addressed,"unexpected second '&' operator");
  addressed = True;
  return *this;
}

inline BlockableObject & NestableContainer::Hook::put ( BlockableObject &obj,int flags )
{
  assign_object(&obj,obj.objectType(),flags);
  return obj;
}

inline const BlockableObject & NestableContainer::Hook::put ( const BlockableObject &obj,int flags )
{
  assign_object(&obj,obj.objectType(),flags);
  return obj;
}

// objref assignment -- assigns copy of ObjRef
inline ObjRef & NestableContainer::Hook::operator = ( const ObjRef &ref ) const
{
  return assign_objref(ref,DMI::PRESERVE_RW|DMI::COPYREF);
}
// objref assignment w/xfer 
inline ObjRef & NestableContainer::Hook::operator <<= ( ObjRef &ref ) const
{
  return assign_objref(ref,DMI::PRESERVE_RW);
}
// index-into operator [id]
inline const NestableContainer::Hook & NestableContainer::Hook::operator [] (const HIID &id) const
{
  FailWhen(addressed,"unexpected '&' operator");
  FailWhen(resid.size(),"uninitialized element ["+resid.toString()+"]"); 
  FailWhen(resindex>=0,ssprintf("uninitialized element [%d]",resindex)); 
  int sep = id.findFirstSlash();
  if( !sep )
    return (*this)[id.subId(1)];
  else if( sep == (int)id.size()-1 )
    return (*this)[id.subId(0,-2)];
  else if( sep > 0 )
    return (*this)[id.subId(0,sep-1)][id.subId(sep+1,-1)];
  const void *newtarget = applyIndex(id);
  if( newtarget )
    target = const_cast<void*>(newtarget);
  else
    resid = id;
  return *this;
}

// index-into operator [n]
inline const NestableContainer::Hook & NestableContainer::Hook::operator [] (int n)  const
{
  FailWhen(addressed,"unexpected '&' operator");
  FailWhen(resid.size(),"uninitialized element ["+resid.toString()+"]"); 
  FailWhen(resindex>=0,ssprintf("uninitialized element [%d]",resindex)); 
  const void *newtarget = applyIndex(n);
  if( newtarget )
    target = const_cast<void*>(newtarget);
  else
    resindex = n;
  return *this;
}

inline bool NestableContainer::Hook::exists () const
{
  return !resid.size() && resindex<0;
}

//## end module%3C10CC830067.epilog


#endif
