//## begin module%1.4%.codegen_version preserve=yes
//   Read the documentation to learn more about C++ code generator
//   versioning.
//## end module%1.4%.codegen_version

//## begin module%3C10CC830067.cm preserve=no
//	  %X% %Q% %Z% %W%
//## end module%3C10CC830067.cm

//## begin module%3C10CC830067.cp preserve=no
//## end module%3C10CC830067.cp

//## Module: NestableContainer%3C10CC830067; Package specification
//## Subsystem: DMI%3C10CC810155
//	f:\lofar\dvl\lofar\cep\cpa\pscf\src
//## Source file: f:\lofar8\oms\LOFAR\cep\cpa\pscf\src\NestableContainer.h

#ifndef NestableContainer_h
#define NestableContainer_h 1

//## begin module%3C10CC830067.additionalIncludes preserve=no
#include "Common.h"
#include "DMI.h"
//## end module%3C10CC830067.additionalIncludes

//## begin module%3C10CC830067.includes preserve=yes
#include "TypeInfo.h"
#include "TID-PSCF.h"
#include "pscf/Timestamp.h"
//## end module%3C10CC830067.includes

// Registry
#include "Registry.h"
// HIIDSet
#include "HIIDSet.h"
// BlockableObject
#include "BlockableObject.h"
//## begin module%3C10CC830067.declarations preserve=no
//## end module%3C10CC830067.declarations

//## begin module%3C10CC830067.additionalDeclarations preserve=yes
using Debug::ssprintf;
//## end module%3C10CC830067.additionalDeclarations


//## begin NestableContainer%3BE97CE100AF.preface preserve=yes
class NestableContainer;
//## end NestableContainer%3BE97CE100AF.preface

//## Class: NestableContainer%3BE97CE100AF; Abstract
//	This is an abstract base class for data containers. It implements
//	hooks (see Hook and ConstHook below) that allow access to elements
//	of the container via the [HIID] and [int] operators.
//
//	To derive a specific container that will be compatible with hooks
//	(and thus can be accessed via []), you need to  implement four
//	virtual methods: get(HIID,...), insert(HIID,...), size(), type().
//	See below for specifics.
//
//	You can optionally implement get(int,...), insert(int...), if
//	accessing via a numeric index is a special case for your container.
//	Also, isContiguous() should be redefined to return True, if your
//	container stores data in a contigouus block of memory.
//## Category: PSCF::DMI%3BEAB1F2006B; Global
//## Subsystem: DMI%3C10CC810155
//## Persistence: Transient
//## Cardinality/Multiplicity: n



//## Uses: <unnamed>%3BFBAF8303C0;HIIDSet { -> }
//## Uses: <unnamed>%3C5A7A4400BF;UniRegistry { -> }

class NestableContainer : public BlockableObject  //## Inherits: <unnamed>%3BFCD87C0106
{
  //## begin NestableContainer%3BE97CE100AF.initialDeclarations preserve=yes
  //## end NestableContainer%3BE97CE100AF.initialDeclarations

  public:
    //## begin NestableContainer::ConstHook%3C614FDE0039.preface preserve=yes
    class ConstHook;
    class Hook;
    //## end NestableContainer::ConstHook%3C614FDE0039.preface

    //## Class: ConstHook%3C614FDE0039
    //	ConstHook is a helper class generated by applying the [id] and [n]
    //	operators to a const NestableContainer. It provides transparent
    //	access to objects in the container.
    //
    //	In addition to the methods documented here, it also provides the
    //	following accessors for all known data types:
    //
    //	T as_T();
    //	operator T (); // for standard types,
    //	const T & as_T ();
    //	operator const T & (); // for all other types,
    //	const T * as_T_p(); // for all types
    //	operator const T *(); // for all types -- but only allowed after the
    //	& operator has been applied.
    //## Category: PSCF::DMI%3BEAB1F2006B; Global
    //## Subsystem: DMI%3C10CC810155
    //## Persistence: Transient
    //## Cardinality/Multiplicity: n



    class ConstHook 
    {
      //## begin NestableContainer::ConstHook%3C614FDE0039.initialDeclarations preserve=yes
      // Note that since Hooks are almost always treated as const 
      // (since they only appear as temporary objects), all their methods have to
      // be declared as const. Ugly, ain't it...
      //## end NestableContainer::ConstHook%3C614FDE0039.initialDeclarations

      public:

        //## Other Operations (specified)
          //## Operation: operator []%3C87377803A8
          //	If the hook points to a container, indexes into the container
          const NestableContainer::ConstHook & operator [] (const HIID &id1) const;

          //## Operation: operator []%3C8737C80081
          const NestableContainer::ConstHook & operator [] (int n) const;

          //## Operation: operator &%3C87364902B3
          //	Address-of: enables implicit conversion-to-pointer operators.
          const NestableContainer::ConstHook & operator & () const;

          //## Operation: exists%3C8737D30041
          //	True if the hook points to a valid, initialized element.
          bool exists () const;

          //## Operation: type%3C8737E002A3
          //	Type of element pointed to. If it is is a fixed-type container, then
          //	returns type of contents instead. Returns 0 (NullType) if element
          //	doesn't exist.
          TypeId type () const;

          //## Operation: actualType%3C8737F702D8
          //	Returns the real type of the element being pointed to. For
          //	containers & dynamic objects, this will usually be TpObjRef rather
          //	than the element type.
          TypeId actualType () const;

          //## Operation: containerType%3C876AFC0254
          //	Returns the type of the container object being pointed to. Returns 0
          //	(NullType) if not pointing to a container.
          TypeId containerType () const;

          //## Operation: isContainer%3C873800017C
          //	Returns True if pointing to a container element.
          bool isContainer () const;

          //## Operation: isRef%3C876FF50114
          //	Returns true if the element being pointed to is held in an ObjRef.
          bool isRef () const;

          //## Operation: size%3C87380503BE
          //	Size of element being pointed to. Always 1 for non-container element
          //	For containers, returns the size of the container. Returns 0 if the
          //	element doesn't exist.
          int size () const;

          //## Operation: ref%3C87703E03D6
          //	If the element  is held in an ObjRef, returns a read-only copy of
          //	the ref. Throws exception otherwise.
          ObjRef ref () const;

        // Additional Public Declarations
          //## begin NestableContainer::ConstHook%3C614FDE0039.public preserve=yes
          friend NestableContainer;
          
          // explicit versions of [] for string IDs
          const NestableContainer::ConstHook & operator [] (const string &id1) const 
          { return (*this)[HIID(id1)]; }
          const NestableContainer::ConstHook & operator [] (const char *id1) const 
          { return (*this)[HIID(id1)]; }
      
          // pull in const accessdor methods
          #include "DataAcc-Const.h"

          // standard debug info
          string sdebug ( int detail = 1,const string &prefix = "",const char *name = "cHook" ) const;
          const char *debug ( int detail = 1,const string &prefix = "",const char *name = "cHook" ) const
          { return Debug::staticBuffer(sdebug(detail,prefix,name)); }

          //## end NestableContainer::ConstHook%3C614FDE0039.public
      protected:
        //## Constructors (specified)
          //## Operation: ConstHook%3C87374503C2
          //	Constructors are protected since only NestableContainers are allowed
          //	to create hooks.
          ConstHook (const NestableContainer &parent, const HIID &id1);

          //## Operation: ConstHook%3C87375E01CA
          ConstHook (const NestableContainer &parent, int n);

        // Data Members for Associations

          //## Association: PSCF::DMI::<unnamed>%3C87362A007E
          //## Role: ConstHook::nc%3C87362B00E3
          //## begin NestableContainer::ConstHook::nc%3C87362B00E3.role preserve=no  protected: NestableContainer { -> 1RHNM}
          mutable NestableContainer *nc;
          //## end NestableContainer::ConstHook::nc%3C87362B00E3.role

        // Additional Protected Declarations
          //## begin NestableContainer::ConstHook%3C614FDE0039.protected preserve=yes
          mutable bool addressed;     // flag: & operator has been applied
          mutable HIID id;            // id being applied to target
          mutable int  index;         // index being applied to target (-1 for not set)
          
          // if target is an ObjRef, returns it, checking for writability
          // else throws an exception
          inline const ObjRef * asRef (bool write=False) const;

          // if target is an NC, returns pointer to it, else 0.
          // if target is not specified, uses the current index
          const NestableContainer * asNestable(const void *target=0,TypeId tid=0) const;
          NestableContainer * asNestableWr(void *target=0,TypeId tid=0) const;
          
          // helper func: collapses the current index and returns new target
          const void * collapseIndex (TypeId &tid,bool &can_write,TypeId check_tid,bool must_write) const;
          
          // helper func: applies exiasting id or index to hook in preparation
           // for setting a new one
          void nextIndex () const;

          // This is called to get a value, for built-in scalar types only
          void get_scalar( void *data,TypeId tid,bool implicit=False ) const;

          // This is called to access by reference, for all types
          const void *get_address(TypeId tid,bool must_write,bool implicit=False,bool pointer=False ) const;

          // This is called to access by pointer, for all types
          const void *get_pointer(TypeId tid,bool must_write,bool implicit=False ) const;

          //## end NestableContainer::ConstHook%3C614FDE0039.protected
      private:
        //## Constructors (generated)
          ConstHook();

        //## Assignment Operation (generated)
          ConstHook & operator=(const ConstHook &right);

        // Additional Private Declarations
          //## begin NestableContainer::ConstHook%3C614FDE0039.private preserve=yes
          //## end NestableContainer::ConstHook%3C614FDE0039.private

      private: //## implementation
        // Additional Implementation Declarations
          //## begin NestableContainer::ConstHook%3C614FDE0039.implementation preserve=yes
          //## end NestableContainer::ConstHook%3C614FDE0039.implementation

    };

    //## begin NestableContainer::ConstHook%3C614FDE0039.postscript preserve=yes
    //## end NestableContainer::ConstHook%3C614FDE0039.postscript

    //## begin NestableContainer::Hook%3C8739B50135.preface preserve=yes
    //## end NestableContainer::Hook%3C8739B50135.preface

    //## Class: Hook%3C8739B50135
    //	Hook is a helper class generated by applying the [id] and [n]
    //	operators to a non-const NestableContainer. It provides read access
    //	methods inherited from ConstHook, plus its own write-access methods.
    //
    //	In addition to the methods documented here, it also provides the
    //	following accessors for all known data types:
    //
    //	T& as_T_wr();
    //	operator T& (); // for strings, binary and dynamic types
    //	T operator = (T); // for standard types
    //	T& operator = (T&); // for strings & binary types
    //	[const] T* operator <<=([const] T*);
    //	[const] T& operator <<=([const] T&); // for dynamic types. This
    //	attaches an anon ref to the object
    //	T* as_T_wp(); // for all types
    //	operator T*(); // for all types - but only allowed after the &
    //	operator has been applied.
    //## Category: PSCF::DMI%3BEAB1F2006B; Global
    //## Subsystem: DMI%3C10CC810155
    //## Persistence: Transient
    //## Cardinality/Multiplicity: n



    class Hook : public ConstHook  //## Inherits: <unnamed>%3C873A010206
    {
      //## begin NestableContainer::Hook%3C8739B50135.initialDeclarations preserve=yes
      //## end NestableContainer::Hook%3C8739B50135.initialDeclarations

      public:

        //## Other Operations (specified)
          //## Operation: operator []%3C8739B50167
          const NestableContainer::Hook & operator [] (const HIID &id1) const;

          //## Operation: operator []%3C8739B50174
          const NestableContainer::Hook & operator [] (int n) const;

          //## Operation: operator &%3C8739B50176
          const NestableContainer::Hook & operator & () const;

          //## Operation: isWritable%3C87665E0178
          //	Returns True if the hook refers to a writable element.
          bool isWritable () const;

          //## Operation: init%3C8739B5017B
          //	Initializes element being pointed to. If element exists, does
          //	nothing.
          const NestableContainer::Hook & init (TypeId tid = 0) const;

          //## Operation: operator =%3C873A8F035F
          const NestableContainer::Hook & operator = (const ObjRef &ref) const;

          //## Operation: operator <<=%3C873AB8008D
          const NestableContainer::Hook & operator <<= (ObjRef &ref) const;

          //## Operation: operator <<=%3C87864D031A
          const NestableContainer::Hook & operator <<= (BlockableObject *obj) const;

          //## Operation: operator <<=%3C8786A30223
          const NestableContainer::Hook & operator <<= (const BlockableObject *obj) const;

          //## Operation: put%3C873AE302FC
          const NestableContainer::Hook & put (BlockableObject &obj, int flags) const;

          //## Operation: put%3C873B8F01C2
          const NestableContainer::Hook & put (const BlockableObject &obj, int flags) const;

          //## Operation: put%3C873B980248
          const NestableContainer::Hook & put (const ObjRef &ref, int flags) const;

          //## Operation: privatize%3C8739B5017C
          //	If container is writable, and the element being pointed to is held
          //	in an ObjRef, then privatizes the ObjRef. Throws exception otherwise.
          const NestableContainer::Hook & privatize (int flags = 0) const;

          //## Operation: ref%3C8770A70215
          //	If the element  is held in an ObjRef, returns a copy of the ref with
          //	the specified flags. Throws exception otherwise.
          ObjRef ref (int flags = DMI::PRESERVE_RW) const;

          //## Operation: remove%3C876DCE0266
          //	Removes the element being pointed to from the container. Returns
          //	True if removed, False if no such element.
          bool remove (ObjRef* ref = 0	// If specified, then
          	// the removed element will be re-attached to this ref. An exception
          	// will be thrown if the element is not held in an ObjRef.
          ) const;

          //## Operation: detach%3C876E140018
          //	Can only be called for elements held in an ObjRef. Detaches element
          //	but leaves the ObjRef in the container. Returnsref to self, so it's
          //	possible to do things like rec[field].detach(&old_ref) <<= new
          //	object;
          const NestableContainer::Hook & detach (ObjRef* ref = 0	// If specified, then the element will be re-attached to this ref.
          ) const;

        // Additional Public Declarations
          //## begin NestableContainer::Hook%3C8739B50135.public preserve=yes
          friend NestableContainer;
          
          // explicit versions of [] for string IDs
          const NestableContainer::Hook & operator [] (const string &id1) const 
          { return (*this)[HIID(id1)]; }
          const NestableContainer::Hook & operator [] (const char *id1) const 
          { return (*this)[HIID(id1)]; }
          
          // pull non-in const accessdor methods
          #define ForceConstDefinitions 1
          #include "DataAcc-NonConst.h"

          string sdebug ( int detail = 1,const string &prefix = "",const char *name = "Hook" ) const
          { return ConstHook::sdebug(detail,prefix,name); }
          const char *debug ( int detail = 1,const string &prefix = "",const char *name = "Hook" ) const
          { return Debug::staticBuffer(sdebug(detail,prefix,name)); }
          //## end NestableContainer::Hook%3C8739B50135.public
      protected:
        //## Constructors (specified)
          //## Operation: Hook%3C8739B50153
          Hook (NestableContainer &parent, const HIID &id1);

          //## Operation: Hook%3C8739B5015E
          Hook (NestableContainer &parent, int n);

        // Additional Protected Declarations
          //## begin NestableContainer::Hook%3C8739B50135.protected preserve=yes
          // Helper function resolves current index to target *
          void * resolveTarget( TypeId &target_tid,TypeId tid ) const;
              
          // This is called to assign a value, for scalar & binary types
          const void * put_scalar( const void *data,TypeId tid,size_t sz ) const;

          // Helper function to assign an object.  
          void assign_object( BlockableObject *obj,TypeId tid,int flags ) const;

          // const version forces a read-only ref
          void assign_object( const BlockableObject *obj,TypeId tid,int flags ) const;

          // Helper function assigns an objref     
          ObjRef & assign_objref ( const ObjRef &ref,int flags ) const;

          //## end NestableContainer::Hook%3C8739B50135.protected
      private:
        //## Constructors (generated)
          Hook();

        //## Assignment Operation (generated)
          Hook & operator=(const Hook &right);

        // Additional Private Declarations
          //## begin NestableContainer::Hook%3C8739B50135.private preserve=yes
          //## end NestableContainer::Hook%3C8739B50135.private

      private: //## implementation
        // Additional Implementation Declarations
          //## begin NestableContainer::Hook%3C8739B50135.implementation preserve=yes
          //## end NestableContainer::Hook%3C8739B50135.implementation

    };

    //## begin NestableContainer::Hook%3C8739B50135.postscript preserve=yes
    //## end NestableContainer::Hook%3C8739B50135.postscript

    //## Constructors (specified)
      //## Operation: NestableContainer%3C7F928D00C0
      NestableContainer (bool write = True);


    //## Other Operations (specified)
      //## Operation: get%3C56A6C50088
      //	get(HIID): Abstract method for dereferencing a container element
      //	indicated by id. Must be implemented by all child classes. This is
      //	the method called by the hook operator [](const HIID &). See Data
      //	Record and DataField for example implementations.
      //	The return value is a pointer to the data element (or to an ObjRef
      //	to the data, see below). A return value of 0 indicates that the
      //	element doesn't exist but can be insert()ed (e.g. no such field in
      //	record). An exception may be thrown otherwise (e.g. array inndex out
      //	of range).
      virtual const void * get (const HIID &id, 	// Specifies an element
      	// in the container.
      	// A null HIID (id.size()==0) implies accessing the entire container.
      	// Throw an exception if this is incompatible with check_tid. E.g. an
      	// array may be accessed as an Array_int, but if it has only a single
      	// element, then also as an int..
      TypeId& tid, 	// Return the actual type of the element here.
      bool& can_write, 	// Return True if the datum is writable, False if not.
      TypeId check_tid = 0, 	// This is the type being requested.
      	// An exception should be thrown if there's a mismatch with the
      	// contents type. The following special cases must be handled:
      	// TpNumeric: any built-in numeric type is expected.
      	// TpObjRef: a dynamic type is expected, return pointer to ObjRef, and
      	// set tid=TpObjRef.
      	// TpObject: a dynamic type is expected, return pointer to actual
      	// object rather than the ref.
      	// 0: no type checking. For dynamic types, returning an ObjRef is
      	// preferred.
      bool must_write = False	// If True and datum is read-only, throw an exception
      ) const = 0;

      //## Operation: getn%3C7A13C90269
      //	getn(int): this is a version of get() with a numeric element
      //	specification. This is the method called by the hook operator
      //	[](int). The default implementation simply converts the index into a
      //	single-index HIID, and calls get(HIID).
      virtual const void * getn (int n, TypeId& tid, bool& can_write, TypeId check_tid = 0, bool must_write = False) const;

      //## Operation: insert%3C7A13D703AA
      //	insert(HIID). This is an abstract ethod for allocating a new element
      //	in a container. Must be implemented by all child classes.
      //	Inserts element and returns a pointer to it. If the data type is
      //	dynamic, then must insert a new (unattached) ObjRef, and return a
      //	pointer to that.
      virtual void * insert (const HIID &id, 	// ID of element to be allocated.
      	// Throw an exception if an element with such an ID can't be inserted
      	// (e.g. arrays can allow insert() only at end of array).
      TypeId tid, 	// Type of element to be inserted.  An exception should be thrown if
      	// this is not compatible with the container (i.e., if the container
      	// is of a fixed type.) Since hooks support implicit conversion
      	// between standard types, no exception should be thrown if both tid
      	// and the container types are standard.
      	// If tid is 0, and the container is of a fixed type and has been
      	// initialized, then a new element should be inserted. Otherwise an
      	// exception should be thrown.
      	// The actual type of the element must always be returned via real_tid.
      TypeId &real_tid	// The actual type inserted into the container is returned here.
      ) = 0;

      //## Operation: insertn%3C7A140A003C
      //	insert(int): this is a version of insert() with a numeric element
      //	specification. The default implementation simply converts the index
      //	into a single-index HIID, and calls insert(HIID).
      virtual void * insertn (int n, TypeId tid, TypeId &real_tid);

      //## Operation: remove%3C87752F031F
      //	Virtual method for removing the element indicated by id.
      //	Should return True if element was removed, False for no such
      //	element, or throw an exception on logic error.
      //	Default implementation throws a "container does not support remove"
      //	exception.
      virtual bool remove (const HIID &id);

      //## Operation: removen%3C87753803B8
      //	remove(int): this is a version of remove() with a numeric element
      //	specification. The default implementation simply converts the index
      //	into a single-index HIID, and calls remove(HIID).
      virtual bool removen (int n);

      //## Operation: size%3C7A154E01AB
      //	Abstract method. Must returns the number of elements in the
      //	container.
      virtual int size () const = 0;

      //## Operation: type%3C7A1552012E
      //	Abstract method. Should return the type of the contents. If
      //	container is not of a fixed type (e.g. a record), or hasn't been
      //	initialized yet, then just return NullType (0).
      virtual TypeId type () const = 0;

      //## Operation: isContiguous%3C7F97CB00F6
      //	Returns True if storage of container is contiguous (i.e., if data[n]
      //	is located at (&data[0])+n). Default implementation returns False.
      virtual bool isContiguous () const;

      //## Operation: operator []%3C8742310264
      NestableContainer::ConstHook operator [] (const HIID &id) const;

      //## Operation: operator []%3C874250006A
      NestableContainer::ConstHook operator [] (int index) const;

      //## Operation: operator []%3C874267026C
      NestableContainer::Hook operator [] (const HIID &id);

      //## Operation: operator []%3C874251027E
      NestableContainer::Hook operator [] (int index);

      //## Operation: select%3BE982760231
      //	Selects a subset of a container. Meant to be abstract, but we make
      //	it just virtual for now since this part is not implemented anywhere.
      virtual bool select (const HIIDSet &id);

      //## Operation: clearSelection%3BFBDC0D025A
      //	Clears the subset selection.
      virtual void clearSelection ();

      //## Operation: selectionToBlock%3BFBDC1D028F
      //	Converts the selected subset to a BlockSet.
      virtual int selectionToBlock (BlockSet& set);

      //## Operation: isNestable%3BFCD8180044
      bool isNestable () const;

      //## Operation: isNestable%3C5551E201AE
      //	Static function, checks if a type is a nestable (or a subclass
      //	thereof).
      static bool isNestable (TypeId tid);

    //## Get and Set Operations for Class Attributes (generated)

      //## Attribute: writable%3C7F924300A6
      bool isWritable () const;

  public:
    // Additional Public Declarations
      //## begin NestableContainer%3BE97CE100AF.public preserve=yes
      friend ConstHook;
      friend Hook;
      
      // explicit versions of [] for string IDs
      NestableContainer::ConstHook operator [] (const string &id1) const
      { return (*this)[HIID(id1)]; }
      NestableContainer::ConstHook operator [] (const char *id1) const
      { return (*this)[HIID(id1)]; }
      NestableContainer::Hook operator [] (const string &id1) 
      { return (*this)[HIID(id1)]; }
      NestableContainer::Hook operator [] (const char *id1) 
      { return (*this)[HIID(id1)]; }

      //## end NestableContainer%3BE97CE100AF.public
  protected:
    // Data Members for Class Attributes

      //## begin NestableContainer::writable%3C7F924300A6.attr preserve=no  public: bool {U} 
      bool writable;
      //## end NestableContainer::writable%3C7F924300A6.attr

    // Additional Protected Declarations
      //## begin NestableContainer%3BE97CE100AF.protected preserve=yes
      //## end NestableContainer%3BE97CE100AF.protected

  private:
    // Additional Private Declarations
      //## begin NestableContainer%3BE97CE100AF.private preserve=yes
      DeclareRegistry(NestableContainer,int,bool);
      //## end NestableContainer%3BE97CE100AF.private
  private: //## implementation
    // Additional Implementation Declarations
      //## begin NestableContainer%3BE97CE100AF.implementation preserve=yes
      //## end NestableContainer%3BE97CE100AF.implementation

};

//## begin NestableContainer%3BE97CE100AF.postscript preserve=yes
//## end NestableContainer%3BE97CE100AF.postscript

// Class NestableContainer::ConstHook 

inline NestableContainer::ConstHook::ConstHook (const NestableContainer &parent, const HIID &id1)
  //## begin NestableContainer::ConstHook::ConstHook%3C87374503C2.hasinit preserve=no
  //## end NestableContainer::ConstHook::ConstHook%3C87374503C2.hasinit
  //## begin NestableContainer::ConstHook::ConstHook%3C87374503C2.initialization preserve=yes
  :  nc(const_cast<NestableContainer *>(&parent)),addressed(False),id(),index(-1)
  //## end NestableContainer::ConstHook::ConstHook%3C87374503C2.initialization
{
  //## begin NestableContainer::ConstHook::ConstHook%3C87374503C2.body preserve=yes
  int sep = id1.findFirstSlash();
  if( sep<0 ) // no slashes - just init id
    id = id1;
  else if( !sep ) // leading slash - strip
    id = id1.subId(1);
  else if( sep == (int)(id.size()-1) ) // trailing slash - strip
    id = id1.subId(0,id1.size()-1);
  else  // embedded slash - split id into two and apply sequentially
  {
    id = id1.subId(0,sep-1);
    (*this)[id1.subId(sep+1)];
  }
  //## end NestableContainer::ConstHook::ConstHook%3C87374503C2.body
}

inline NestableContainer::ConstHook::ConstHook (const NestableContainer &parent, int n)
  //## begin NestableContainer::ConstHook::ConstHook%3C87375E01CA.hasinit preserve=no
  //## end NestableContainer::ConstHook::ConstHook%3C87375E01CA.hasinit
  //## begin NestableContainer::ConstHook::ConstHook%3C87375E01CA.initialization preserve=yes
   : nc(const_cast<NestableContainer *>(&parent)),addressed(False),id(),index(n)
  //## end NestableContainer::ConstHook::ConstHook%3C87375E01CA.initialization
{
  //## begin NestableContainer::ConstHook::ConstHook%3C87375E01CA.body preserve=yes
  //## end NestableContainer::ConstHook::ConstHook%3C87375E01CA.body
}



//## Other Operations (inline)
inline const NestableContainer::ConstHook & NestableContainer::ConstHook::operator [] (const HIID &id1) const
{
  //## begin NestableContainer::ConstHook::operator []%3C87377803A8.body preserve=yes
  FailWhen(addressed,"unexpected '&' operator");
  int sep = id1.findFirstSlash();
  if( !sep )
    return (*this)[id1.subId(1)];
  else if( sep == (int)(id.size()-1) )
    return (*this)[id1.subId(0,id1.size()-1)];
  else if( sep > 0 )
    return (*this)[id1.subId(0,sep-1)][id1.subId(sep+1)];
  nextIndex();
  id=id1; index=-1;
  return *this;
  //## end NestableContainer::ConstHook::operator []%3C87377803A8.body
}

inline const NestableContainer::ConstHook & NestableContainer::ConstHook::operator [] (int n) const
{
  //## begin NestableContainer::ConstHook::operator []%3C8737C80081.body preserve=yes
  FailWhen(addressed,"unexpected '&' operator");
  nextIndex();
  id.clear(); index=n;
  return *this;
  //## end NestableContainer::ConstHook::operator []%3C8737C80081.body
}

inline const NestableContainer::ConstHook & NestableContainer::ConstHook::operator & () const
{
  //## begin NestableContainer::ConstHook::operator &%3C87364902B3.body preserve=yes
  FailWhen(addressed,"unexpected second '&' operator");
  addressed = True;
  return *this;
  //## end NestableContainer::ConstHook::operator &%3C87364902B3.body
}

inline bool NestableContainer::ConstHook::exists () const
{
  //## begin NestableContainer::ConstHook::exists%3C8737D30041.body preserve=yes
  TypeId tid; bool dum;
  return collapseIndex(tid,dum,0,False) != 0;
  //## end NestableContainer::ConstHook::exists%3C8737D30041.body
}

inline TypeId NestableContainer::ConstHook::type () const
{
  //## begin NestableContainer::ConstHook::type%3C8737E002A3.body preserve=yes
  TypeId tid; bool dum;
  const void *targ = collapseIndex(tid,dum,0,False);
  if( !targ )
    return 0;
  const NestableContainer *nc1 = asNestable(targ,tid);
  return nc1 ? nc1->type() : tid;
  //## end NestableContainer::ConstHook::type%3C8737E002A3.body
}

inline TypeId NestableContainer::ConstHook::actualType () const
{
  //## begin NestableContainer::ConstHook::actualType%3C8737F702D8.body preserve=yes
  TypeId tid; bool dum;
  const void *targ = collapseIndex(tid,dum,0,False);
  return targ ? tid : NullType;
  //## end NestableContainer::ConstHook::actualType%3C8737F702D8.body
}

inline TypeId NestableContainer::ConstHook::containerType () const
{
  //## begin NestableContainer::ConstHook::containerType%3C876AFC0254.body preserve=yes
  const NestableContainer *nc = asNestable();
  return nc ? nc->objectType() : NullType;
  //## end NestableContainer::ConstHook::containerType%3C876AFC0254.body
}

inline bool NestableContainer::ConstHook::isContainer () const
{
  //## begin NestableContainer::ConstHook::isContainer%3C873800017C.body preserve=yes
  return asNestable() != 0;
  //## end NestableContainer::ConstHook::isContainer%3C873800017C.body
}

inline bool NestableContainer::ConstHook::isRef () const
{
  //## begin NestableContainer::ConstHook::isRef%3C876FF50114.body preserve=yes
  TypeId tid; bool dum;
  const void *target = collapseIndex(tid,dum,0,False);
  return target && tid == TpObjRef;
  //## end NestableContainer::ConstHook::isRef%3C876FF50114.body
}

inline int NestableContainer::ConstHook::size () const
{
  //## begin NestableContainer::ConstHook::size%3C87380503BE.body preserve=yes
  TypeId tid; bool dum;
  const void *targ = collapseIndex(tid,dum,0,False);
  if( !targ )
    return 0;
  const NestableContainer *nc1 = asNestable();
  return nc1 ? nc1->size() : 1;
  //## end NestableContainer::ConstHook::size%3C87380503BE.body
}

inline ObjRef NestableContainer::ConstHook::ref () const
{
  //## begin NestableContainer::ConstHook::ref%3C87703E03D6.body preserve=yes
  return ObjRef(*asRef(),DMI::READONLY|DMI::COPYREF);
  //## end NestableContainer::ConstHook::ref%3C87703E03D6.body
}

// Class NestableContainer::Hook 

inline NestableContainer::Hook::Hook (NestableContainer &parent, const HIID &id1)
  //## begin NestableContainer::Hook::Hook%3C8739B50153.hasinit preserve=no
  //## end NestableContainer::Hook::Hook%3C8739B50153.hasinit
  //## begin NestableContainer::Hook::Hook%3C8739B50153.initialization preserve=yes
    : ConstHook(parent,id1)
  //## end NestableContainer::Hook::Hook%3C8739B50153.initialization
{
  //## begin NestableContainer::Hook::Hook%3C8739B50153.body preserve=yes
  //## end NestableContainer::Hook::Hook%3C8739B50153.body
}

inline NestableContainer::Hook::Hook (NestableContainer &parent, int n)
  //## begin NestableContainer::Hook::Hook%3C8739B5015E.hasinit preserve=no
  //## end NestableContainer::Hook::Hook%3C8739B5015E.hasinit
  //## begin NestableContainer::Hook::Hook%3C8739B5015E.initialization preserve=yes
    : ConstHook(parent,n)
  //## end NestableContainer::Hook::Hook%3C8739B5015E.initialization
{
  //## begin NestableContainer::Hook::Hook%3C8739B5015E.body preserve=yes
  //## end NestableContainer::Hook::Hook%3C8739B5015E.body
}



//## Other Operations (inline)
inline const NestableContainer::Hook & NestableContainer::Hook::operator [] (const HIID &id1) const
{
  //## begin NestableContainer::Hook::operator []%3C8739B50167.body preserve=yes
  ConstHook::operator [](id1);
  return *this;
  //## end NestableContainer::Hook::operator []%3C8739B50167.body
}

inline const NestableContainer::Hook & NestableContainer::Hook::operator [] (int n) const
{
  //## begin NestableContainer::Hook::operator []%3C8739B50174.body preserve=yes
  ConstHook::operator [](n);
  return *this;
  //## end NestableContainer::Hook::operator []%3C8739B50174.body
}

inline const NestableContainer::Hook & NestableContainer::Hook::operator & () const
{
  //## begin NestableContainer::Hook::operator &%3C8739B50176.body preserve=yes
  ConstHook::operator &();
  return *this;
  //## end NestableContainer::Hook::operator &%3C8739B50176.body
}

inline const NestableContainer::Hook & NestableContainer::Hook::operator = (const ObjRef &ref) const
{
  //## begin NestableContainer::Hook::operator =%3C873A8F035F.body preserve=yes
  assign_objref(ref,DMI::PRESERVE_RW|DMI::COPYREF);
  return *this;
  //## end NestableContainer::Hook::operator =%3C873A8F035F.body
}

inline const NestableContainer::Hook & NestableContainer::Hook::operator <<= (ObjRef &ref) const
{
  //## begin NestableContainer::Hook::operator <<=%3C873AB8008D.body preserve=yes
  assign_objref(ref,DMI::PRESERVE_RW);
  return *this;
  //## end NestableContainer::Hook::operator <<=%3C873AB8008D.body
}

inline const NestableContainer::Hook & NestableContainer::Hook::operator <<= (BlockableObject *obj) const
{
  //## begin NestableContainer::Hook::operator <<=%3C87864D031A.body preserve=yes
  assign_object(obj,obj->objectType(),DMI::ANON|DMI::WRITE);
  return *this;
  //## end NestableContainer::Hook::operator <<=%3C87864D031A.body
}

inline const NestableContainer::Hook & NestableContainer::Hook::operator <<= (const BlockableObject *obj) const
{
  //## begin NestableContainer::Hook::operator <<=%3C8786A30223.body preserve=yes
  assign_object(obj,obj->objectType(),DMI::ANON|DMI::READONLY);
  return *this;
  //## end NestableContainer::Hook::operator <<=%3C8786A30223.body
}

inline const NestableContainer::Hook & NestableContainer::Hook::put (BlockableObject &obj, int flags) const
{
  //## begin NestableContainer::Hook::put%3C873AE302FC.body preserve=yes
  assign_object(&obj,obj.objectType(),flags);
  return *this;
  //## end NestableContainer::Hook::put%3C873AE302FC.body
}

inline const NestableContainer::Hook & NestableContainer::Hook::put (const BlockableObject &obj, int flags) const
{
  //## begin NestableContainer::Hook::put%3C873B8F01C2.body preserve=yes
  assign_object(&obj,obj.objectType(),flags);
  return *this;
  //## end NestableContainer::Hook::put%3C873B8F01C2.body
}

inline const NestableContainer::Hook & NestableContainer::Hook::put (const ObjRef &ref, int flags) const
{
  //## begin NestableContainer::Hook::put%3C873B980248.body preserve=yes
  assign_objref(ref,flags);
  return *this;
  //## end NestableContainer::Hook::put%3C873B980248.body
}

inline ObjRef NestableContainer::Hook::ref (int flags) const
{
  //## begin NestableContainer::Hook::ref%3C8770A70215.body preserve=yes
  return ObjRef(*asRef(),flags|DMI::COPYREF);
  //## end NestableContainer::Hook::ref%3C8770A70215.body
}

// Class NestableContainer 

inline NestableContainer::NestableContainer (bool write)
  //## begin NestableContainer::NestableContainer%3C7F928D00C0.hasinit preserve=no
  //## end NestableContainer::NestableContainer%3C7F928D00C0.hasinit
  //## begin NestableContainer::NestableContainer%3C7F928D00C0.initialization preserve=yes
  : writable(write)
  //## end NestableContainer::NestableContainer%3C7F928D00C0.initialization
{
  //## begin NestableContainer::NestableContainer%3C7F928D00C0.body preserve=yes
  //## end NestableContainer::NestableContainer%3C7F928D00C0.body
}



//## Other Operations (inline)
inline const void * NestableContainer::getn (int n, TypeId& tid, bool& can_write, TypeId check_tid, bool must_write) const
{
  //## begin NestableContainer::getn%3C7A13C90269.body preserve=yes
  return get(HIID(n),tid,can_write,check_tid,must_write);
  //## end NestableContainer::getn%3C7A13C90269.body
}

inline void * NestableContainer::insertn (int n, TypeId tid, TypeId &real_tid)
{
  //## begin NestableContainer::insertn%3C7A140A003C.body preserve=yes
  return insert(HIID(n),tid,real_tid);
  //## end NestableContainer::insertn%3C7A140A003C.body
}

inline bool NestableContainer::remove (const HIID &id)
{
  //## begin NestableContainer::remove%3C87752F031F.body preserve=yes
  Throw("container does not support remove("+id.toString()+")");
  //## end NestableContainer::remove%3C87752F031F.body
}

inline bool NestableContainer::removen (int n)
{
  //## begin NestableContainer::removen%3C87753803B8.body preserve=yes
  return remove(HIID(n));
  //## end NestableContainer::removen%3C87753803B8.body
}

inline bool NestableContainer::isContiguous () const
{
  //## begin NestableContainer::isContiguous%3C7F97CB00F6.body preserve=yes
  return False;
  //## end NestableContainer::isContiguous%3C7F97CB00F6.body
}

inline NestableContainer::ConstHook NestableContainer::operator [] (const HIID &id) const
{
  //## begin NestableContainer::operator []%3C8742310264.body preserve=yes
  return ConstHook(*this,id);
  //## end NestableContainer::operator []%3C8742310264.body
}

inline NestableContainer::ConstHook NestableContainer::operator [] (int index) const
{
  //## begin NestableContainer::operator []%3C874250006A.body preserve=yes
  return ConstHook(*this,index);
  //## end NestableContainer::operator []%3C874250006A.body
}

inline NestableContainer::Hook NestableContainer::operator [] (const HIID &id)
{
  //## begin NestableContainer::operator []%3C874267026C.body preserve=yes
  return Hook(*this,id);
  //## end NestableContainer::operator []%3C874267026C.body
}

inline NestableContainer::Hook NestableContainer::operator [] (int index)
{
  //## begin NestableContainer::operator []%3C874251027E.body preserve=yes
  return Hook(*this,index);
  //## end NestableContainer::operator []%3C874251027E.body
}

inline bool NestableContainer::isNestable () const
{
  //## begin NestableContainer::isNestable%3BFCD8180044.body preserve=yes
  //## end NestableContainer::isNestable%3BFCD8180044.body

  return True;

}

inline bool NestableContainer::isNestable (TypeId tid)
{
  //## begin NestableContainer::isNestable%3C5551E201AE.body preserve=yes
  return registry.find(tid);
  //## end NestableContainer::isNestable%3C5551E201AE.body
}

//## Get and Set Operations for Class Attributes (inline)

inline bool NestableContainer::isWritable () const
{
  //## begin NestableContainer::isWritable%3C7F924300A6.get preserve=no
  return writable;
  //## end NestableContainer::isWritable%3C7F924300A6.get
}

//## begin module%3C10CC830067.epilog preserve=yes

inline const ObjRef * NestableContainer::ConstHook::asRef( bool write ) const
{
  FailWhen(addressed,"unexpected '&' operator");
  TypeId tid; bool dum;
  const void *target = collapseIndex(tid,dum,0,write);
  FailWhen(!target,"element does not exist");
  FailWhen(tid!=TpObjRef,"element is not held in an ObjRef");
  return static_cast<const ObjRef*>(target);
}

// This is called to access by pointer, for all types
inline const void * NestableContainer::ConstHook::get_pointer(TypeId tid,bool must_write,bool implicit ) const
{
  FailWhen(!addressed && implicit,"missing '&' operator");
  return get_address(tid,must_write,implicit,True);
}

inline const void * NestableContainer::ConstHook::collapseIndex (TypeId &tid,
    bool &can_write,TypeId check_tid,bool must_write) const
{
  return index<0 
      ? nc->get(id,tid,can_write,check_tid,must_write)
      : nc->getn(index,tid,can_write,check_tid,must_write);
}

// helper function applies exiasting id or index to hook in preparation
// for setting a new one
inline void NestableContainer::ConstHook::nextIndex () const
{
  // index into container for new target
  const NestableContainer *newnc = asNestable();
  FailWhen(!newnc,"indexing into non-existing or non-container element");
  nc = const_cast<NestableContainer*>(newnc);
}

// const version forces a read-only ref
inline void NestableContainer::Hook::assign_object( const BlockableObject *obj,TypeId tid,int flags ) const
{
  // cast away const but that's OK since we force r/o ref  
  return assign_object(const_cast<BlockableObject*>(obj),tid,(flags&~DMI::WRITE)|DMI::READONLY);
}

//## end module%3C10CC830067.epilog


#endif


// Detached code regions:
#if 0
//## begin NestableContainer::Hook::detach%3C876E140018.body preserve=yes
  ObjRef *ref0 = const_cast<ObjRef*>( asRef(True) );
  ref0->unlock();
  if( ref )
    ref->xfer(ref0);
  else
    ref0->detach();
  return *ref0;
//## end NestableContainer::Hook::detach%3C876E140018.body

#endif
